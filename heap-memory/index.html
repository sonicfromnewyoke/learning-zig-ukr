<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <meta name="description" content="Вивчаємо Zig Українською. Zig — імперативна, статично типізована, компільована системна мова програмування загального призначення.">
    <meta property="og:title" content="Динамічна пам&apos;ять та розподільники пам&apos;яті">
    <meta property="og:type" content="website">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      Динамічна пам&apos;ять та розподільники пам&apos;яті
      Вивчаємо Zig Українською
    </title>
    <link rel="icon" href="/learning-zig-ukr/favicon.png">
    <link rel="stylesheet" type="text/css" href="/learning-zig-ukr/style.css">
    <link rel="stylesheet" type="text/css" href="/learning-zig-ukr/highlight.css">
    
  </head>
  <body>
    <header>
      <h1>Вивчаємо Zig Українською</h1>
    </header>
    <div id="main-wrapper">
      <div id="navigation">
        <nav aria-labelledby="table-of-contents">
          <h2 id="table-of-contents">Зміст</h2>
          <ul>
            <li><a id="toc-Index" href="/learning-zig-ukr/">Вступ</a></li>
            <li><a id="toc-Language-Overview-1" href="/learning-zig-ukr/language-overview-1/">Огляд Мови, частина 1</a></li>
            <li><a id="toc-Language-Overview-2" href="/learning-zig-ukr/language-overview-2/">Огляд Мови, частина 2</a></li>
            <li><a id="toc-Style-Guide" href="/learning-zig-ukr/style-guide/">Керівництво по стилю оформлення</a></li>
            <li><a id="toc-Pointers" href="/learning-zig-ukr/pointers/">Вказівники</a></li>
            <li><a id="toc-Stack-Memory" href="/learning-zig-ukr/stack-memory/">Стекова пам'ять</a></li>
            <li><a id="toc-Heap-Memory" href="/learning-zig-ukr/heap-memory/">Динамічна пам'ять та розподільники пам'яті</a></li>
            <li><a id="toc-Generics" href="/learning-zig-ukr/generics/">Узагальнені структури даних</a></li>
            <li><a id="toc-Coding-In-Zig" href="/learning-zig-ukr/coding-in-zig/">Програмуємо мовою Zig</a></li>
            <li><a id="toc-Conclusion" href="/learning-zig-ukr/conclusion/">Висоновки</a></li>
          </ul>
        </nav>
      </div>
      <div id="contents-wrapper">
        <div id="contents">
          
		<h1 var="Динамічна пам&apos;ять та розподільники пам&apos;яті"></h1>
		<div id="docs"><p>Усе, що ми бачили досі, мало попередньо відомий розмір. Масиви завжди мають відому довжину під час компіляції (фактично, довжина є частиною типу). Усі наші рядки були рядковими літералами, які мають відому довжину під час компіляції.</p><p>Крім того, два типи стратегій керування пам’яттю, які ми бачили, глобальні дані та стек викликів, хоч і є простими та ефективними, але є обмеженими. Жодна з них не може мати справу з даними динамічного розміру, і обидва є жорсткими щодо тривалості життя даних.</p><p>Ця частина розділена на дві теми. Перша - це загальний огляд нашої третьої області пам’яті, купи. Інша — простий, але унікальний підхід Zig до керування пам’яттю купи. Навіть якщо ви знайомі з куповою пам’яттю, скажімо, з використанням <code>malloc</code> C, ви захочете прочитати першу частину, оскільки вона досить специфічна для Zig.</p><h2>Динамічна памʼять (heap, “куча”)</h2><p>Купа - це третя і остання область пам’яті в нашому розпорядженні. Порівняно як з глобальними даними, так і зі стеком викликів, купа виглядає як дикий захід: все підійде. Зокрема, у купі ми можемо створити пам’ять під час виконання з відомим розміром часу виконання та мати повний контроль над часом її життя.</p><p>Стек викликів дивовижний завдяки простому та передбачуваному способу керування даними (шляхом вставляння та висування кадрів стеку). Ця перевага також є недоліком: час життя даних прив’язаний до їх місця в стеку викликів. Купа - точнісінько навпаки. Він не має вбудованого життєвого циклу, тому наші дані можуть зберігатися стільки часу, скільки потрібно. І ця перевага є його недоліком: він не має вбудованого життєвого циклу, тому, якщо ми не звільнимо дані, ніхто цього не зробить.</p><p>Давайте розглянемо приклад:</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="comment">// незабаром ми поговоримо про розподільники</span>
  <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// ** Наступні два рядки є важливими **</span>
  <span class="type qualifier">var</span> <span class="variable">arr</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="type builtin">usize</span><span class="punctuation delimiter">,</span> <span class="operator">try</span> <span class="variable">getRandomCount</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword">defer</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">arr</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="repeat">for</span> <span class="punctuation bracket">(</span><span class="number">0</span><span class="punctuation special">..</span><span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">len</span><span class="punctuation bracket">)</span> |<span class="variable">i</span>| <span class="punctuation bracket">{</span>
    <span class="variable">arr</span><span class="punctuation bracket">[</span><span class="variable">i</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="variable">i</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;{any}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">arr</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword function">fn</span> <span class="function">getRandomCount</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">u8</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">seed</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span> = <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
  <span class="operator">try</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">posix</span><span class="punctuation delimiter">.</span><span class="function">getrandom</span><span class="punctuation bracket">(</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="function">asBytes</span><span class="punctuation bracket">(</span><span class="operator">&amp;</span><span class="variable">seed</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">var</span> <span class="variable">random</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">Random</span><span class="punctuation delimiter">.</span><span class="field">DefaultPrng</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">seed</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword return">return</span> <span class="variable">random</span><span class="punctuation delimiter">.</span><span class="function">random</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">uintAtMost</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="number">5</span><span class="punctuation bracket">)</span> <span class="operator">+</span> <span class="number">5</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Незабаром ми розглянемо розподілювачі Zig, поки знаємо, що <code>allocator</code> є <code>std.mem.Allocator</code>. Ми використовуємо два його методи: <code>alloc</code> і <code>free</code>. Оскільки ми викликаємо <code>allocator.alloc</code> за допомогою <code>try</code>, ми знаємо, що цей виклик може закінчитись з помилко. Наразі єдиною можливою помилкою є <code>OutOfMemory</code>. Його параметри здебільшого розповідають нам, як він працює: йому потрібен тип (<code>T</code>), а також кількість <code>і</code>, якщо виклик успішний, повернеться зріз <code>[]T</code>. Цей розподіл відбувається під час виконання - наша кількість відома лише під час виконання.</p><p>Як правило, кожен <code>alloc</code> матиме відповідний <code>free</code>. Якщо <code>alloc</code> виділяє пам’ять, <code>free</code> звільняє її. Не дозволяйте цьому простому коду обмежувати вашу уяву. Цей шаблон <code>try alloc</code> + <code>defer free</code> <em>є</em> поширеним явищем і з поважної причини: звільнення поблизу того місця, де ми розподіляємо, відносно надійне. Але не менш поширеним є виділення в одному місці, а звільнення в іншому. Як ми вже говорили раніше, купа не має вбудованого управління життєвим циклом. Ви можете виділити пам’ять у обробнику HTTP та звільнити її у фоновому потоці, двох повністю окремих частинах коду.</p><h2><code>defer</code> & <code>errdefer</code></h2><p>Як невеликий обхід, вищенаведений код представив нову функцію мови: <code>defer</code>, яка виконує заданий код, або блок, після виходу з області видимості. “Вихід зобласті видимості” включає досягнення кінця області або повернення з неї. <code>defer</code> не пов’язаний суворо з розподільниками чи керуванням пам’яттю; ви можете використовувати його для виконання будь-якого коду. Але наведене вище використання є поширеним.</p><p>Відкладення Zig схоже на Go, з однією істотною відмінністю. У Zig відкладення буде запущено в кінці його області видимості. У Go defer запускається в кінці функції, що містить. Підхід Zig, ймовірно, менш дивовижний, якщо ви не розробник Go.</p><p>Схожим до <code>defer</code> є <code>errdefer</code>, який подібним чином виконує заданий код або блок під час виходу з області видимості, але лише тоді, коли повертається помилка. Це корисно, коли виконується складніше налаштування та потрібно скасувати попередній розподіл через помилку.</p><p>Наступний приклад - стрибок у складності. Він демонструє як <code>errdefer</code>, так і загальний шаблон, який передбачає виділення <code>init</code> і звільнення <code>deinit</code>:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">Allocator</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="field">Allocator</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">Game</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">players</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="variable">Player</span><span class="punctuation delimiter">,</span>
  <span class="field">history</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="variable">Move</span><span class="punctuation delimiter">,</span>
  <span class="field">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation delimiter">,</span>

  <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="parameter">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation delimiter">,</span> <span class="parameter">player_count</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="variable">Game</span> <span class="punctuation bracket">{</span>
    <span class="type qualifier">var</span> <span class="variable">players</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="variable">Player</span><span class="punctuation delimiter">,</span> <span class="variable">player_count</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword">errdefer</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">players</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// зберігати 10 останніх ходів на гравця</span>
    <span class="type qualifier">var</span> <span class="variable">history</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="variable">Move</span><span class="punctuation delimiter">,</span> <span class="variable">player_count</span> <span class="operator">*</span> <span class="number">10</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
      <span class="punctuation delimiter">.</span><span class="field">players</span> = <span class="variable">players</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">history</span> = <span class="variable">history</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">allocator</span> = <span class="variable">allocator</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>

  <span class="keyword function">fn</span> <span class="function">deinit</span><span class="punctuation bracket">(</span><span class="parameter">game</span><span class="punctuation delimiter">:</span> <span class="variable">Game</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">game</span><span class="punctuation delimiter">.</span><span class="field">allocator</span><span class="punctuation delimiter">;</span>
    <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">game</span><span class="punctuation delimiter">.</span><span class="field">players</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">game</span><span class="punctuation delimiter">.</span><span class="field">history</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Сподіваюся, це підкреслює дві речі. По-перше, корисність errdefer. За нормальних умов <code>players</code> виділяється в <code>init</code> і звільняється в <code>deinit</code>. Але є граничний випадок, коли ініціалізація <code>history</code> не вдається. У цьому і тільки в цьому випадку нам потрібно скасувати розподіл <code>players</code>.</p><p>Другий вартий уваги аспект цього коду полягає в тому, що життєвий цикл наших двох динамічно розподілених зрізів, <code>players</code> та <code>history</code>, базується на логіці нашої програми. Немає правила, яке б вказувало, коли потрібно викликати <code>deinit</code> або хто його має викликати. Це добре, тому що це дає нам довільний час життя, але погано, тому що ми можемо зіпсувати це, ніколи не викликаючи <code>deinit</code> або викликаючи його більше одного разу.</p><hr><blockquote><p>Назви <code>init</code> і <code>deinit</code> не є особливими. Це саме те, що використовує стандартна бібліотека Zig і те, що прийняла спільнота. У деяких випадках, зокрема у стандартній бібліотеці, використовуються <code>open</code> та <code>close</code> або інші більш відповідні назви.</p></blockquote><hr><h2>Повторне звільнення та витоки пам’яті</h2><p>Трохи вище я згадав, що не існує правил, які регулюють, коли щось потрібно звільнити. Але це не зовсім так, є кілька важливих правил, які просто не нвʼязуює ніхто силоміць, окрім вашої власної педантичності.</p><p>Перше правило полягає в тому, що ви не можете звільнити ту саму пам’ять двічі.</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">arr</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="type builtin">usize</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">arr</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">arr</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Цей рядок не надрукується\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Останній рядок цього коду є пророчим, його <em>не</em> буде надруковано. Це тому, що ми двічі <code>free</code> ту саму пам’ять. Це відоме як подвійне вивільнення памʼяті і це не працює. Це може здатися досить простим, щоб уникнути, але у великих проектах зі складним терміном служби це може бути важко відстежити.</p><p>Друге правило полягає в тому, що ви не можете звільнити пам’ять, на яку не маєте посилання. Це може здатися очевидним, але не завжди зрозуміло, хто відповідальний за його звільнення. Наступне створює новий рядок у нижньому регістрі:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">Allocator</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="field">Allocator</span><span class="punctuation delimiter">;</span>

<span class="keyword function">fn</span> <span class="function">allocLower</span><span class="punctuation bracket">(</span><span class="parameter">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation delimiter">,</span> <span class="parameter">str</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">dest</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="variable">str</span><span class="punctuation delimiter">.</span><span class="field">len</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="repeat">for</span> <span class="punctuation bracket">(</span><span class="variable">str</span><span class="punctuation delimiter">,</span> <span class="number">0</span><span class="punctuation special">..</span><span class="punctuation bracket">)</span> |<span class="variable">c</span><span class="punctuation delimiter">,</span> <span class="variable">i</span>| <span class="punctuation bracket">{</span>
    <span class="variable">dest</span><span class="punctuation bracket">[</span><span class="variable">i</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="conditional">switch</span> <span class="punctuation bracket">(</span><span class="variable">c</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
      <span class="character">&apos;A&apos;</span><span class="punctuation special">...</span><span class="character">&apos;Z&apos;</span> =&gt; <span class="variable">c</span> <span class="operator">+</span> <span class="number">32</span><span class="punctuation delimiter">,</span>
      <span class="conditional">else</span> =&gt; <span class="variable">c</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>

  <span class="keyword return">return</span> <span class="variable">dest</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Наведений вище код правильний. Але наступне використання не є таким:</p><pre><code class="zig"><span class="comment">// Для цього конкретного коду ми повинні були використовувати std.ascii.eqlIgnoreCase</span>
<span class="keyword function">fn</span> <span class="function">isSpecial</span><span class="punctuation bracket">(</span><span class="parameter">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation delimiter">,</span> <span class="parameter">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span> <span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">bool</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">lower</span> = <span class="operator">try</span> <span class="variable">allocLower</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation delimiter">,</span> <span class="variable">name</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword return">return</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="function">eql</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="variable">lower</span><span class="punctuation delimiter">,</span> <span class="string">&quot;admin&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Це витік пам’яті. Пам’ять, створена в <code>allocLower</code>, ніколи не звільняється. Мало того, коли <code>isSpecial</code> повертається, його вже не можна буде звільнити. У мовах із збиральниками сміття, коли дані стають недоступними, вони зрештою звільняються збирачем сміття. Але в наведеному вище коді, коли <code>isSpecial</code> повертається, ми втрачаємо єдине посилання на виділену пам’ять, змінну <code>lower</code>. Пам’ять зникла, доки наш процес не завершить роботу. Наша функція може втрачати лише кілька байтів, але якщо це тривалий процес і ця функція викликається неодноразово, вона <em>буде</em> додаватися, і врешті-решт у нас вичерпається пам’ять.</p><p>Принаймні у випадку з подвійним вивільненням ми отримаємо жорсткий збій. Витоки пам’яті можуть бути підступними. Справа не тільки в тому, що першопричину важко визначити. Дійсно невеликі витоки або витоки в коді, що виконується рідко, може бути ще важче виявити. Це настільки поширена проблема, що Zig дійсно надає допомогу, що ми побачимо, коли будемо говорити про розподільники.</p><h2><code>create</code> та <code>destroy</code></h2><p>Метод <code>alloc</code> <code>std.mem.Allocator</code> повертає фрагмент із довжиною, яка була передана як 2-й параметр. Якщо вам потрібно єдине значення, використовуйте <code>create</code> і <code>destroy</code> замість <code>alloc</code> і <code>free</code>. Кілька частин тому, коли ми вивчали вказівники, ми створили <code>User</code> і спробували збільшити його потужність. Ось робоча версія цього коду на основі купи, яка використовує <code>create:</code></p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="comment">// знову ж таки, скоро ми поговоримо про розподільники!</span>
  <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// створюємо User в кучі</span>
  <span class="type qualifier">var</span> <span class="variable">user</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">create</span><span class="punctuation bracket">(</span><span class="variable">User</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// звільняємо пам&apos;ять, виділену для користувача в кінці цієї області</span>
  <span class="keyword">defer</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">destroy</span><span class="punctuation bracket">(</span><span class="variable">user</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">id</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
  <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation delimiter">;</span>

  <span class="comment">// додали цей рядок</span>
  <span class="variable">levelUp</span><span class="punctuation bracket">(</span><span class="variable">user</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Користувач {d} має силу {d}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">id</span><span class="punctuation delimiter">,</span> <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword function">fn</span> <span class="function">levelUp</span><span class="punctuation bracket">(</span><span class="parameter">user</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">User</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">id</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Метод <code>create</code> приймає один параметр, тип (<code>T</code>). Він повертає покажчик на цей тип або помилку, наприклад <code>!*T</code>. Можливо, вам цікаво, що станеться, якщо ми створимо нашого <code>user</code>, але не встановимо <code>id</code> та/або <code>power</code>. Це схоже на встановлення для цих полів значення <code>undefined</code>, і поведінка буде, ну, невизначеною.</p><p>Коли ми досліджували висячі покажчики, у нас була функція, яка неправильно повертала адресу локального користувача:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="parameter">id</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span> <span class="parameter">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation bracket">)</span> <span class="operator">*</span><span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="type qualifier">var</span> <span class="variable">user</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
      <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="variable">id</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="variable">power</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="comment">// це &quot;висячий&quot; вказівник</span>
    <span class="keyword return">return</span> <span class="operator">&amp;</span><span class="variable">user</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>У цьому випадку було б доцільніше повернути <code>User</code>. Але іноді вам <em>буде</em> потрібно, щоб функція повертала вказівник на те, що вона створює. Ви зробите це, якщо захочете все життя бути вільним від жорсткості стека викликів. Щоб вирішити наш висячий покажчик вище, ми могли б використати <code>create</code>:</p><pre><code class="zig"><span class="comment">// наш тип повернення змінено, оскільки ініціалізація тепер може завершитися помилкою</span>
<span class="comment">// *User -&gt; !*User</span>
<span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="parameter">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="field">Allocator</span><span class="punctuation delimiter">,</span> <span class="parameter">id</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span> <span class="parameter">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="operator">*</span><span class="variable">User</span><span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">user</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">create</span><span class="punctuation bracket">(</span><span class="variable">User</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">user</span><span class="operator">.*</span> <span class="operator">=</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="variable">id</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="variable">power</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="keyword return">return</span> <span class="variable">user</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Я представив новий синтаксис, <code>user._ = {...}</code>. Це трохи дивно, і мені це не подобається, але ви це побачите. Права сторона – це те, що ви вже бачили: це ініціалізатор структури з виведеним типом. Ми могли б бути явними та використати: <code>user._ = User{...}</code>. У лівій частині, <code>user.*</code>, ми розіменовуємо покажчик. <code>&amp;</code> приймає <code>T</code> і дає нам <code>*T</code>. <code>.*</code> протилежний, застосований до значення типу <code>*T</code>, він дає нам <code>T</code>. Пам’ятайте, що <code>create</code> повертає <code>!*User</code>, тому наш <code>user</code> має тип <code>*User</code>.</p><h2>Розподільники (Allocators)</h2><p>Одним із основних принципів Zig є те, що в ньому <strong>немає прихованого розподілу пам’яті</strong>. Залежно від вашого попереднього досвіду це може звучати не надто особливо. Але це різкий контраст із тим, що ви знайдете в C, де пам’ять виділяється за допомогою функції <code>malloc</code> стандартної бібліотеки. У C, якщо ви хочете знати, чи функція виділяє пам’ять, вам потрібно прочитати вихідний код та знайти виклики <code>malloc</code>.</p><p>Zig не має розподілювача за замовчуванням. У всіх наведених вище прикладах функції, які виділяли пам’ять, отримували параметр <code>std.mem.Allocator</code>. За домовленістю це зазвичай перший параметр. Усі стандартні бібліотеки Zig і більшість сторонніх бібліотек вимагають від викликача надати розподільник, якщо вони мають намір виділити пам’ять.</p><p>Ця явність може мати одну з двох форм. У простих випадках розподільник надається під час кожного виклику функції. Є багато прикладів цього, але <code>std.fmt.allocPrint</code> — це той, який вам швидше за все знадобиться рано чи пізно. Він схожий на <code>std.debug.print</code>, який ми використовували, але виділяє та повертає рядок замість запису його в stderr:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">say</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">fmt</span><span class="punctuation delimiter">.</span><span class="function">allocPrint</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation delimiter">,</span> <span class="string">&quot;Цу більше ніж {d}!!!&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">defer</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">say</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>Інша форма — коли розподільник передається в <code>init</code>, а потім використовується внутрішньо об’єктом. Ми бачили це вище з нашою структурою <code>Game</code>. Це менш явно, оскільки ви надали об’єкту розподільник для використання, але ви не знаєте, виклики якого методу насправді розподілять. Такий підхід більш практичний для об’єктів, що живуть довго.</p><p>Перевага введення розподільника полягає не лише в чіткості, але й у гнучкості. <code>std.mem.Allocator</code> — це інтерфейс, який забезпечує функції <code>alloc</code>, <code>free</code>, <code>create</code> і <code>destroy</code>, а також деякі інші. Поки що ми бачили лише <code>std.heap.GeneralPurposeAllocator</code>, але інші реалізації доступні в стандартній бібліотеці або як сторонні бібліотеки.</p><hr><blockquote><p>Zig не має гарного синтаксичного цукру для створення інтерфейсів. Одним із шаблонів поведінки, подібної до інтерфейсу, є об’єднання тегів, хоча це відносно обмежено порівняно зі справжніми інтерфейсами. З’явилися й інші шаблони, які використовуються в стандартній бібліотеці, як-от <code>std.mem.Allocator</code>. Якщо вам цікаво, я написав окрему публікацію в блозі, пояснюючи інтерфейси.</p></blockquote><hr><p>Якщо ви створюєте бібліотеку, то найкраще прийняти <code>std.mem.Allocator</code> і дозволити користувачам вашої бібліотеки вирішувати, яку реалізацію розподільника використовувати. В іншому випадку вам потрібно буде вибрати правильний розподільник, і, як ми побачимо, вони не є взаємовиключними. Можуть бути вагомі причини для створення різних розподільників у вашій програмі.</p><h2>Розподільник Загального Призначення (General Purpose Allocator)</h2><p>Як випливає з назви, <code>std.heap.GeneralPurposeAllocator</code> — це універсальний потокобезпечний розподільник загального призначення, який може служити основним розподільником вашої програми. Для багатьох програм це буде єдиний необхідний розподільник. Під час запуску програми створюється розподільник і передається функціям, які його потребують. Приклад коду з моєї бібліотеки HTTP-сервера є хорошим прикладом:</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">httpz</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;httpz&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="comment">// створюємо наш розподільник загального призначення</span>
  <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="comment">// отримуємо з нього std.mem.Allocator</span>
  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// передаємо наш розподільник функціям і бібліотекам, які його потребують</span>
  <span class="type qualifier">var</span> <span class="variable">server</span> = <span class="operator">try</span> <span class="variable">httpz</span><span class="punctuation delimiter">.</span><span class="function">Server</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">port</span> = <span class="number">5882</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">router</span> = <span class="variable">server</span><span class="punctuation delimiter">.</span><span class="function">router</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">router</span><span class="punctuation delimiter">.</span><span class="function">get</span><span class="punctuation bracket">(</span><span class="string">&quot;/api/user/:id&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">getUser</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// блокуємо поточний потік</span>
  <span class="operator">try</span> <span class="variable">server</span><span class="punctuation delimiter">.</span><span class="function">listen</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Ми створюємо <code>GeneralPurposeAllocator</code>, отримуємо з нього <code>std.mem.Allocator</code> і передаємо його функції <code>init</code> HTTP-сервера. У складнішому проекті «розподільник» буде передано до кількох частин коду, кожна з яких, можливо, передасть його до своїх власних функцій, об’єктів і залежностей.</p><p>Ви можете помітити, що синтаксис створення <code>gpa</code> є трохи дивним. Що це таке: <code>GeneralPurposeAllocator(.{}){}</code>? Це всі речі, які ми бачили раніше, просто зібрані разом. <code>std.heap.GeneralPurposeAllocator</code> — це функція, і оскільки вона використовує PascalCase, ми знаємо, що вона повертає тип. (Більше про узагальнені функції ми поговоримо в наступній частині). Знаючи, що він повертає тип, можливо, цю більш чітку версію буде легше зрозуміти:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">T</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">T</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

<span class="comment">// те саме що</span>

<span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Можливо, ви все ще не впевнені щодо значення <code>.{}</code>. Це також те, що ми бачили раніше: це ініціалізатор структури з неявним типом. Який тип і де знаходяться поля? Типом є <code>std.heap.general_purpose_allocator.Config</code>, хоча він не представлений безпосередньо таким чином, що є однією з причин, чому ми не є явними. Поля не встановлюються, оскільки структура <code>Config</code> визначає значення за замовчуванням, які ми будемо використовувати. Це загальний шаблон для конфігурації/параметрів. Фактично, ми бачимо це знову кількома рядками нижче, коли передаємо <code>.{.port = 5882}</code> в <code>init</code>. У цьому випадку ми використовуємо значення за замовчуванням для всіх полів, крім одного, <code>port</code>.</p><h2>Розподільник для тестування <code>std.testing.allocator</code></h2><p>Сподіваюся, ви були достатньо стурбовані, коли ми говорили про витік пам’яті, а потім хотіли дізнатися більше, коли я згадав, що Zig може допомогти. Ця інформація надходить від <code>std.testing.allocator</code>, який є <code>std.mem.Allocator</code>. Наразі це реалізовано за допомогою <code>GeneralPurposeAllocator</code> з доданою інтеграцією в програму виконання тестів Zig, але це деталі реалізації. Важливо те, що якщо ми використовуємо <code>std.testing.allocator</code> у наших тестах, ми можемо вловити більшість витоків пам’яті.</p><p>Ймовірно, ви вже знайомі з динамічними масивами, які часто називають ArrayLists. У багатьох мовах динамічного програмування всі масиви є динамічними масивами. Динамічні масиви підтримують змінну кількість елементів. Zig має відповідний загальний ArrayList, але ми створимо його спеціально для зберігання цілих чисел і для демонстрації виявлення витоків:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">IntList</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">pos</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span><span class="punctuation delimiter">,</span>
  <span class="field">items</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type builtin">i64</span><span class="punctuation delimiter">,</span>
  <span class="field">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation delimiter">,</span>

  <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="parameter">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="variable">IntList</span> <span class="punctuation bracket">{</span>
    <span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
      <span class="punctuation delimiter">.</span><span class="field">pos</span> = <span class="number">0</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">allocator</span> = <span class="variable">allocator</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">items</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="type builtin">i64</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>

  <span class="keyword function">fn</span> <span class="function">deinit</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="variable">IntList</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>

  <span class="keyword function">fn</span> <span class="function">add</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">IntList</span><span class="punctuation delimiter">,</span> <span class="parameter">value</span><span class="punctuation delimiter">:</span> <span class="type builtin">i64</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="type qualifier">const</span> <span class="variable">pos</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">pos</span><span class="punctuation delimiter">;</span>
    <span class="type qualifier">const</span> <span class="variable">len</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation delimiter">.</span><span class="field">len</span><span class="punctuation delimiter">;</span>

    <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">pos</span> <span class="operator">==</span> <span class="variable">len</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
      <span class="comment">// закінчилось місце</span>
      <span class="comment">// створюємо зріз, що в 2 рази більший</span>
      <span class="type qualifier">var</span> <span class="variable">larger</span> = <span class="operator">try</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="type builtin">i64</span><span class="punctuation delimiter">,</span> <span class="variable">len</span> <span class="operator">*</span> <span class="number">2</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

      <span class="comment">// копіюємо елементи які ми перед цим додали в наш простір</span>
      <span class="function builtin">@memcpy</span><span class="punctuation bracket">(</span><span class="variable">larger</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation special">..</span><span class="variable">len</span><span class="punctuation bracket">]</span><span class="punctuation delimiter">,</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

      <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span> <span class="operator">=</span> <span class="variable">larger</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>

    <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="variable">pos</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="variable">value</span><span class="punctuation delimiter">;</span>
    <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">pos</span> <span class="operator">=</span> <span class="variable">pos</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Цікава частина відбувається в <code>add</code>, коли <code>pos == len</code> вказує, що ми заповнили наш поточний масив і потрібно створити більший. Ми можемо використовувати <code>IntList</code> так:</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">Allocator</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="field">Allocator</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">list</span> = <span class="operator">try</span> <span class="variable">IntList</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword">defer</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="repeat">for</span> <span class="punctuation bracket">(</span><span class="number">0</span><span class="punctuation special">..</span><span class="number">10</span><span class="punctuation bracket">)</span> |<span class="variable">i</span>| <span class="punctuation bracket">{</span>
    <span class="operator">try</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="function">add</span><span class="punctuation bracket">(</span><span class="function builtin">@intCast</span><span class="punctuation bracket">(</span><span class="variable">i</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>

  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;{any}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">list</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation special">..</span><span class="variable">list</span><span class="punctuation delimiter">.</span><span class="field">pos</span><span class="punctuation bracket">]</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Код запускається та друкує правильний результат. Однак, незважаючи на те, що ми <em>справді</em> викликали <code>deinit</code> у <code>list</code>, є витік пам’яті. Нічого страшного, якщо ви не зрозуміли, тому що ми напишемо тест і використаємо <code>std.testing.allocator</code>:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">testing</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">testing</span><span class="punctuation delimiter">;</span>
<span class="keyword">test</span> <span class="string">&quot;IntList: add&quot;</span> <span class="punctuation bracket">{</span>
  <span class="comment">// ми використовуємо testing.allocator тут!</span>
  <span class="type qualifier">var</span> <span class="variable">list</span> = <span class="operator">try</span> <span class="variable">IntList</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">testing</span><span class="punctuation delimiter">.</span><span class="field">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword">defer</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="repeat">for</span> <span class="punctuation bracket">(</span><span class="number">0</span><span class="punctuation special">..</span><span class="number">5</span><span class="punctuation bracket">)</span> |<span class="variable">i</span>| <span class="punctuation bracket">{</span>
    <span class="operator">try</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="function">add</span><span class="punctuation bracket">(</span><span class="function builtin">@intCast</span><span class="punctuation bracket">(</span><span class="variable">i</span><span class="operator">+</span><span class="number">10</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>

  <span class="operator">try</span> <span class="variable">testing</span><span class="punctuation delimiter">.</span><span class="function">expectEqual</span><span class="punctuation bracket">(</span><span class="function builtin">@as</span><span class="punctuation bracket">(</span><span class="type builtin">usize</span><span class="punctuation delimiter">,</span> <span class="number">5</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="field">pos</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="operator">try</span> <span class="variable">testing</span><span class="punctuation delimiter">.</span><span class="function">expectEqual</span><span class="punctuation bracket">(</span><span class="function builtin">@as</span><span class="punctuation bracket">(</span><span class="type builtin">i64</span><span class="punctuation delimiter">,</span> <span class="number">10</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation bracket">]</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="operator">try</span> <span class="variable">testing</span><span class="punctuation delimiter">.</span><span class="function">expectEqual</span><span class="punctuation bracket">(</span><span class="function builtin">@as</span><span class="punctuation bracket">(</span><span class="type builtin">i64</span><span class="punctuation delimiter">,</span> <span class="number">11</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation bracket">]</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="operator">try</span> <span class="variable">testing</span><span class="punctuation delimiter">.</span><span class="function">expectEqual</span><span class="punctuation bracket">(</span><span class="function builtin">@as</span><span class="punctuation bracket">(</span><span class="type builtin">i64</span><span class="punctuation delimiter">,</span> <span class="number">12</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">2</span><span class="punctuation bracket">]</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="operator">try</span> <span class="variable">testing</span><span class="punctuation delimiter">.</span><span class="function">expectEqual</span><span class="punctuation bracket">(</span><span class="function builtin">@as</span><span class="punctuation bracket">(</span><span class="type builtin">i64</span><span class="punctuation delimiter">,</span> <span class="number">13</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">3</span><span class="punctuation bracket">]</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="operator">try</span> <span class="variable">testing</span><span class="punctuation delimiter">.</span><span class="function">expectEqual</span><span class="punctuation bracket">(</span><span class="function builtin">@as</span><span class="punctuation bracket">(</span><span class="type builtin">i64</span><span class="punctuation delimiter">,</span> <span class="number">14</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">4</span><span class="punctuation bracket">]</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<hr><blockquote><p><code>@as</code> є вбудованим, який виконує приведення типу. Якщо вам цікаво, чому в нашому тесті було використано так багато з них, ви не єдині. Технічно це тому, що другий параметр, «фактичний», примусово ставиться до першого, «очікуваного». У наведеному вище «очікуваними» є всі <code>comptime_int</code>, що викликає проблеми. Багато хто, включаючи мене, вважають це <a href="https://github.com/ziglang/zig/issues/4437"" target="_blank">дивною та невдалою поведінкою</a>.</p></blockquote><hr><p>Якщо ви слідкуєте, помістіть тест у той самий файл, що й <code>IntList</code> і <code>main</code>. Zig-тести зазвичай записуються в одному файлі, часто поруч із кодом, який вони тестують. Коли ми використовуємо <code>zig test learning.zig</code> для запуску нашого тесту, ми отримуємо дивовижну помилку:</p><pre><code>Test [1/1] test.IntList: add... [gpa] (err): memory address 0x101154000 leaked:
/code/zig/learning.zig:26:32: 0x100f707b7 in init (test)
   .items = try allocator.alloc(i64, 2),
                               ^
/code/zig/learning.zig:55:29: 0x100f711df in test.IntList: add (test)
 var list = try IntList.init(testing.allocator);

... MORE STACK INFO ...

[gpa] (err): memory address 0x101184000 leaked:
/code/test/learning.zig:40:41: 0x100f70c73 in add (test)
   var larger = try self.allocator.alloc(i64, len * 2);
                                        ^
/code/test/learning.zig:59:15: 0x100f7130f in test.IntList: add (test)
  try list.add(@intCast(i+10));
</code></pre><p>Ми маємо численні витоки пам’яті. На щастя, розподільник тестування повідомляє нам, де саме було виділено витік пам’яті. Чи можете ви зараз помітити витік? Якщо ні, пам’ятайте, що, загалом, кожен <code>alloc</code> повинен мати відповідний <code>free</code>. Наш код викликає <code>free</code> один раз, у <code>deinit</code>. Однак <code>alloc</code> викликається один раз у <code>init</code>, а потім кожного разу, коли викликається <code>add</code>, і нам потрібно більше місця. Щоразу, коли ми <code>alloc</code> більше місця, нам потрібно <code>free</code> попередні <code>self.items</code>:</p><pre><code class="zig"><span class="comment">// існуючий код</span>
<span class="type qualifier">var</span> <span class="variable">larger</span> = <span class="operator">try</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="type builtin">i64</span><span class="punctuation delimiter">,</span> <span class="variable">len</span> <span class="operator">*</span> <span class="number">2</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="function builtin">@memcpy</span><span class="punctuation bracket">(</span><span class="variable">larger</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation special">..</span><span class="variable">len</span><span class="punctuation bracket">]</span><span class="punctuation delimiter">,</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">)</span><span class="error">;

// доданий код
// звільнюємо попередні алокації
self</span><span class="punctuation delimiter">.</span><span class="variable builtin">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>Додавання цього останнього рядка після копіювання елементів до нашого «більшого» фрагмента вирішує проблему. Якщо ви запустите <code>zig test learning.zig</code>, помилки бути не повинно.</p><h2>Розподільник на основі Регіонів (ArenaAllocator)</h2><p>GeneralPurposeAllocator є розумним за замовчуванням, оскільки він добре працює в усіх можливих випадках. Але в програмі ви можете зіткнутися з шаблонами розподілу, які можуть отримати користь від більш спеціалізованих розподільників. Одним із прикладів є потреба в короткочасному стані, який можна відкинути після завершення обробки. Парсери часто мають таку вимогу. Скелетна функція <code>parse</code> може виглядати так:</p><pre><code class="zig"><span class="keyword function">fn</span> <span class="function">parse</span><span class="punctuation bracket">(</span><span class="parameter">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation delimiter">,</span> <span class="parameter">input</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="variable">Something</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">state</span> = <span class="variable">State</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">buf</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="number">512</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">nesting</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="variable">NestType</span><span class="punctuation delimiter">,</span> <span class="number">10</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="keyword">defer</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">state</span><span class="punctuation delimiter">.</span><span class="field">buf</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword">defer</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">state</span><span class="punctuation delimiter">.</span><span class="field">nesting</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="keyword return">return</span> <span class="variable">parseInternal</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation delimiter">,</span> <span class="variable">state</span><span class="punctuation delimiter">,</span> <span class="variable">input</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Хоча це не надто важко керувати, <code>parseInternal</code> може потребувати інших короткочасних розподілів, які потрібно буде звільнити. Як альтернативу ми можемо створити ArenaAllocator, який дозволить нам звільнити всі розподіли за один раз:</p><pre><code class="zig"><span class="keyword function">fn</span> <span class="function">parse</span><span class="punctuation bracket">(</span><span class="parameter">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation delimiter">,</span> <span class="parameter">input</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="variable">Something</span> <span class="punctuation bracket">{</span>
  <span class="comment">// створюємо ArenaAllocator з наданого allocator</span>
  <span class="type qualifier">var</span> <span class="variable">arena</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="field">ArenaAllocator</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// це звільнить усе, що створено в цьому регіоні</span>
  <span class="keyword">defer</span> <span class="variable">arena</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// створюємо std.mem.Allocator з arena, це буде</span>
  <span class="comment">// розподільник який ми використаємо в середині</span>
  <span class="type qualifier">const</span> <span class="variable">aa</span> = <span class="variable">arena</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">const</span> <span class="variable">state</span> = <span class="variable">State</span><span class="punctuation bracket">{</span>
    <span class="comment">// ми використовуєсо using aa тут!</span>
    <span class="punctuation delimiter">.</span><span class="field">buf</span> = <span class="operator">try</span> <span class="variable">aa</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="number">512</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>

    <span class="comment">// ми використовуєсо using aa тут!</span>
    <span class="punctuation delimiter">.</span><span class="field">nesting</span> = <span class="operator">try</span> <span class="variable">aa</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="variable">NestType</span><span class="punctuation delimiter">,</span> <span class="number">10</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="comment">// ми передаємо aa тут, тож гарантуємо що</span>
  <span class="comment">// будь-яке виділення памʼяті буде в нашому регіоні</span>
  <span class="keyword return">return</span> <span class="variable">parseInternal</span><span class="punctuation bracket">(</span><span class="variable">aa</span><span class="punctuation delimiter">,</span> <span class="variable">state</span><span class="punctuation delimiter">,</span> <span class="variable">input</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p><code>ArenaAllocator</code> приймає дочірній розподільник, у цьому випадку розподільник, який було передано в <code>init</code>, і створює новий <code>std.mem.Allocator</code>. Коли цей новий розподільник використовується для виділення або створення пам’яті, нам не потрібно викликати <code>free</code> або <code>destroy</code>. Все буде опубліковано, коли ми викличемо <code>deinit</code> на <code>arena</code>. Насправді команди <code>free</code> та <code>destroy</code> ArenaAllocator нічого не роблять.</p><p><code>ArenaAllocator</code> слід використовувати обережно. Оскільки немає способу звільнити окремі виділення, ви повинні бути впевнені, що <code>deinit</code> арени буде викликано в межах розумного збільшення пам’яті. Цікаво, що це знання може бути внутрішнім або зовнішнім. Наприклад, у наведеному вище скелеті використання ArenaAllocator має сенс зсередини аналізатора, оскільки подробиці про час існування стану є внутрішньою справою.</p><hr><blockquote><p>Такі розподільники, як ArenaAllocator, які мають механізм звільнення всіх попередніх виділень, можуть порушити правило, згідно з яким кожен <code>alloc</code> повинен мати відповідний <code>free</code>. Однак, якщо ви отримуєте <code>std.mem.Allocator</code>, вам не слід робити жодних припущень щодо базової реалізації.</p></blockquote><hr><p>Те саме не можна сказати про наш <code>IntList</code>. Його можна використовувати для зберігання 10 або 10 мільйонів значень. Тривалість його життя може вимірюватися мілісекундами або тижнями. Він не в змозі визначити тип розподілювача для використання. Ці знання має код, який використовує <code>IntList</code>. Спочатку ми керували нашим <code>IntList</code> так:</p><pre><code class="zig"><span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="type qualifier">var</span> <span class="variable">list</span> = <span class="operator">try</span> <span class="variable">IntList</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">defer</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>Натомість ми могли вибрати ArenaAllocator:</p><pre><code class="zig"><span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="type qualifier">var</span> <span class="variable">arena</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="field">ArenaAllocator</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">defer</span> <span class="variable">arena</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="error">;</span>
<span class="type qualifier">const</span> <span class="variable">aa</span> = <span class="variable">arena</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="type qualifier">var</span> <span class="variable">list</span> = <span class="operator">try</span> <span class="variable">IntList</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">aa</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="comment">// Чесно кажучи, я сумніваюся, чи варто викликати list.deinit чи ні.</span>
<span class="comment">// Технічно це не потрібно, оскільки ми викликаємо defer arena.deinit() вище.</span>
<span class="variable">defer</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="error">;

..</span><span class="punctuation delimiter">.</span><span class="variable builtin"></span><span class="constant"></span>
</code></pre>
<p>Нам не потрібно змінювати <code>IntList</code>, оскільки він має справу лише з <code>std.mem.Allocator</code>. І якби <code>IntList</code> <em>створив</em> внутрішньо власну арену, це теж спрацювало б. Немає причин, щоб ви не могли створити арену в арені.</p><p>Як останній швидкий приклад, HTTP-сервер, про який я згадував вище, надає розподільник арени у <code>Response</code>. Після надсилання відповіді арена звільняється. Передбачуваний термін служби арени (від початку запиту до кінця запиту) робить його ефективним варіантом. Ефективний з точки зору продуктивності та простоти використання.</p><h2>Розподільник з фіксованим буфером (FixedBufferAllocator)</h2><p>Останній розподільник, який ми розглянемо, це <code>std.heap.FixedBufferAllocator</code>, який виділяє пам’ять із буфера (тобто <code>[]u8</code>), який ми надаємо. Цей розподільник має дві основні переваги. По-перше, оскільки вся пам’ять, яку він може використовувати, створюється заздалегідь, це швидко. По-друге, це природним чином обмежує обсяг пам’яті, який можна виділити. Це жорстке обмеження також можна розглядати як недолік. Іншим недоліком є ​​те, що <code>free</code> і <code>destroy</code> працюватимуть лише на останньому виділеному/створеному елементі (подумайте про стек). Звільнення не останнього розподілу є безпечним для виклику, але нічого не дасть.</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">buf</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="number">150</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span> = <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">var</span> <span class="variable">fa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="field">FixedBufferAllocator</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="operator">&amp;</span><span class="variable">buf</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// це звільнить всю пам&apos;ять, виділену цим розподільником</span>
  <span class="keyword">defer</span> <span class="variable">fa</span><span class="punctuation delimiter">.</span><span class="function">reset</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">fa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">const</span> <span class="variable">json</span> = <span class="operator">try</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">json</span><span class="punctuation delimiter">.</span><span class="function">stringifyAlloc</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">this_is</span> = <span class="string">&quot;an anonymous struct&quot;</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">above</span> = <span class="boolean">true</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">last_param</span> = <span class="string">&quot;are options&quot;</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">whitespace</span> = <span class="punctuation delimiter">.</span><span class="variable builtin">indent_2</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// Ми можемо звільнити цей розподіл, але оскільки ми знаємо, що наш розподільник є</span>
  <span class="comment">// FixedBufferAllocator, ми можемо покладатися на наведений вище `defer fa.reset()`</span>
  <span class="keyword">defer</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">json</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;{s}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">json</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>це виведе:</p><pre><code>{
  &quot;this_is&quot;: &quot;an anonymous struct&quot;,
  &quot;above&quot;: true,
  &quot;last_param&quot;: &quot;are options&quot;
}
</code></pre><p>Але змініть наш <code>buf</code> на <code>[120]u8</code>, і ви отримаєте помилку <code>OutOfMemory</code>.</p><p>Загальний шаблон для FixedBufferAllocators і, меншою мірою, ArenaAllocators, полягає в тому, щоб <code>reset</code> їх і повторно використовувати. Це звільняє всі попередні виділення та дозволяє повторно використовувати розподільник.</p><p>Через відсутність розподільника за замовчуванням Zig є прозорим і гнучким щодо розподілу. Інтерфейс <code>std.mem.Allocator</code> є потужним, що дозволяє спеціалізованим розподільникам обгортати більш загальні, як ми бачили з <code>ArenaAllocator</code>.</p><p>У більш загальному плані потужність і пов’язані з нею обов’язки розподілу купи, сподіваюся, очевидні. Можливість виділяти пам’ять довільного розміру з довільним часом життя є важливою для більшості програм.</p><p>Однак через складність динамічної пам’яті слід шукати альтернативи. Наприклад, вище ми використовували <code>std.fmt.allocPrint</code>, але стандартна бібліотека також має <code>std.fmt.bufPrint</code>. Останній використовує буфер замість розподільника:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">name</span> = <span class="string">&quot;Leto&quot;</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">buf</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="number">100</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span> = <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">greeting</span> = <span class="operator">try</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">fmt</span><span class="punctuation delimiter">.</span><span class="function">bufPrint</span><span class="punctuation bracket">(</span><span class="operator">&amp;</span><span class="variable">buf</span><span class="punctuation delimiter">,</span> <span class="string">&quot;Hello {s}&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">name</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;{s}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">greeting</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Цей API перекладає тягар керування пам’яттю на абонента. Якби ми мали довший <code>name</code> або менший <code>buf</code>, наш <code>bufPrint</code> міг би повернути помилку <code>NoSpaceLeft</code>. Але є багато сценаріїв, коли програма має відомі обмеження, наприклад максимальну довжину імені. У таких випадках <code>bufPrint</code> безпечніший і швидший.</p><p>Іншою можливою альтернативою динамічному розподілу є потокова передача даних у <code>std.io.Writer</code>. Як і наш <code>Allocator</code>, <code>Writer</code> є інтерфейсом, реалізованим багатьма типами, наприклад файлами. Вище ми використали <code>stringifyAlloc</code> для серіалізації JSON у динамічно виділений рядок. Ми могли б використати <code>stringify</code> і надати <code>Writer</code>:</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">out</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">io</span><span class="punctuation delimiter">.</span><span class="function">getStdOut</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="operator">try</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">json</span><span class="punctuation delimiter">.</span><span class="function">stringify</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">this_is</span> = <span class="string">&quot;an anonymous struct&quot;</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">above</span> = <span class="boolean">true</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">last_param</span> = <span class="string">&quot;are options&quot;</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">whitespace</span> = <span class="punctuation delimiter">.</span><span class="variable builtin">indent_2</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span> <span class="variable">out</span><span class="punctuation delimiter">.</span><span class="function">writer</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<hr><blockquote><p>У той час як розподільники часто вказуються як перший параметр функції, автори зазвичай є останніми. <code>ಠ_ಠ</code></p></blockquote><hr><p>У багатьох випадках загортання нашого записувача в <code>std.io.BufferedWriter</code> дасть хороше підвищення продуктивності.</p><p>Мета полягає не в тому, щоб усунути всі динамічні розподіли. Це не спрацює, оскільки ці альтернативи мають сенс лише в окремих випадках. Але тепер у вашому розпорядженні багато варіантів. Від кадрів стека до розподілювача загального призначення та всього іншого, наприклад статичних буферів, потокових записувачів і спеціалізованих розподільників.</p></div>
	
        </div>
      </div>
    </div>
  </body>
</html>