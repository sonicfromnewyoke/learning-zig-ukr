<!DOCTYPE html>
<html>

<head id="head">
  <meta charset="UTF-8">
  <meta name="description" content="Вивчаємо Zig Українською">
  <meta property="og:title" content="Вказівники">
  <meta property="og:type" content="website">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title id="title">
    Вказівники
      Вивчаємо Zig Українською
  </title>
  <link rel="stylesheet" type="text/css" href="/learning-zig-ukr/style.css">
  <link rel="stylesheet" type="text/css" href="/learning-zig-ukr/highlight.css">
  
</head>

<body>
  <header>
    <h1>Вивчаємо Zig Українською</h1>
  </header>
  <div id="main-wrapper">
    <div id="navigation">
      <nav aria-labelledby="table-of-contents">
        <h2 id="table-of-contents">Зміст</h2>
        <ul>
          <li><a id="toc-Index" href="/learning-zig-ukr/">Вступ</a></li>
          <li><a id="toc-Language-Overview-1" href="/learning-zig-ukr/language-overview-1">Огляд Мови, частина 1</a></li>
          <li><a id="toc-Language-Overview-2" href="/learning-zig-ukr/language-overview-2">Огляд Мови, частина 2</a></li>
          <li><a id="toc-Style-Guide" href="/learning-zig-ukr/style-guide">Керівництво по стилю оформлення</a></li>
          <li><a id="toc-Pointers" href="/learning-zig-ukr/pointers">Вказівники</a></li>
          <li><a id="toc-Stack-Memory" href="/learning-zig-ukr/stack-memory">Стекова пам'ять</a></li>
          <li><a id="toc-Heap-Memory" href="/learning-zig-ukr/heap-memory">Динамічна пам'ять та розподільники пам'яті</a></li>
          <li><a id="toc-Generics" href="/learning-zig-ukr/generics">Узагальнені структури даних</a></li>
          <li><a id="toc-Coding-In-Zig" href="/learning-zig-ukr/coding-in-zig">Програмуємо мовою Zig</a></li>
          <li><a id="toc-Conclusion" href="/learning-zig-ukr/conclusion">Висоновки</a></li>
        </ul>
      </nav>
    </div>
    <div id="contents-wrapper">
      <div id="content">
        
		<h1 >Вказівники</h1>
		<div id="docs" ><p>Zig не містить збирача сміття. Тягар керування пам’яттю лежить на вас, розробнику. Це велика відповідальність, оскільки вона безпосередньо впливає на продуктивність, стабільність і безпеку вашої програми.</p><p>Ми почнемо з розмови про вказівники, що є важливою темою для обговорення само по собі, але також для того, щоб навчитися бачити дані нашої програми з точки зору, орієнтованої на пам’ять. Якщо ви вже знайомі з покажчиками, розподілом купи та висячими покажчиками, сміливо пропустіть кілька частин до <a href="/heap-memory">пам’яті купи та розподільників</a>, яка більше стосується Zig.</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">user</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="number">1</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">100</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="comment">// цей рядок додано</span>
  <span class="variable">levelUp</span><span class="punctuation bracket">(</span><span class="variable">user</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"Користувач {d} має силу {d}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">id</span><span class="punctuation delimiter">,</span> <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword function">fn</span> <span class="function">levelUp</span><span class="punctuation bracket">(</span><span class="parameter">user</span><span class="punctuation delimiter">:</span> <span class="variable">User</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">id</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
</figure>
<p>Це був нечесний трюк; код не компілюється: <i>local variable is never mutated</i>. Це посилання на змінну <code>user</code> у <code>main</code>. Змінна, яка ніколи не змінюється, має бути оголошена <code>const</code>. Ви можете подумати: але в <code>levelUp</code> ми <i>пере</i> змінюємо <code>user</code>, що дає? Припустімо, що компілятор Zig помиляється, і обдуримо його. Ми змусимо компілятор побачити, що <code>user</code> змінено:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">user</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="number">1</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">100</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">+=</span> <span class="number">0</span><span class="punctuation delimiter">;</span>

  <span class="comment">// решта коду така сама</span><span class="punctuation bracket"></span>
</code></pre>
<p>Тепер ми отримуємо помилку в <code>levelUp</code>: <i>cannot assign to constant</i>. У частині 1 ми побачили, що параметри функції є константами, тому <code>user.power += 1;</code> недійсний. Щоб виправити помилку під час компіляції, ми можемо змінити функцію <code>levelUp</code> на:</p><pre><code class="zig"><span class="keyword function">fn</span> <span class="function">levelUp</span><span class="punctuation bracket">(</span><span class="parameter">user</span><span class="punctuation delimiter">:</span> <span class="variable">User</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">u</span> = <span class="variable">user</span><span class="punctuation delimiter">;</span>
  <span class="variable">u</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Котрий буде скомпільований, але наш вихід такий: <i>Користувач 1 має силу 100</i>, навіть незважаючи на те, що намір нашого коду явно полягає в тому, щоб <code>levelUp</code> збільшив потужність користувача до <code>101</code>. що відбувається</p><p>Для розуміння корисно розглядати дані стосовно пам’яті, а змінні – як мітки, які пов’язують тип із певним місцем пам’яті. Наприклад, у <code>main</code> ми створюємо <code>User</code>. Проста візуалізація цих даних у пам’яті буде виглядати так:</p><pre><code>user -&gt; ------------ (id)
        |    1     |
        ------------ (power)
        |   100    |
        ------------
</code></pre><p>Слід зазначити дві важливі речі. По-перше, наша змінна <code>user</code> вказує на початок нашої структури. По-друге, поля викладаються послідовно. Пам’ятайте, що наш «користувач» також має тип. Цей тип повідомляє нам, що <code>id</code> є 64-бітним цілим числом, а <code>power</code> є 32-бітним цілим числом. Маючи посилання на початок наших даних і тип, компілятор може перекласти <code>user.power</code> на: <i>access a 32 bit integer located 64 bits from the beginning.</i> Це потужність змінних, вони посилаються на пам’ять і включають вводити інформацію, необхідну для осмисленого розуміння та маніпулювання пам’яттю.</p><hr><blockquote><p>За замовчуванням Zig не дає гарантій щодо розташування структур у пам’яті. Він може зберігати поля в алфавітному порядку, за зростанням розміру або з пропусками. Він може робити те, що хоче, якщо зможе правильно перекладати наш код. Ця свобода може дозволити певну оптимізацію. Лише якщо ми оголосимо <code>упаковану структуру</code>, ми отримаємо сильні гарантії щодо розташування пам’яті. Ми також можемо створити «зовнішню структуру», яка гарантує, що макет пам’яті відповідатиме бінарному інтерфейсу програм C (ABI). Тим не менш, наша візуалізація "користувача" є розумною та корисною.</p></blockquote><hr><p>Ось трохи інша візуалізація, яка включає адреси пам’яті. Адреса пам’яті початку цих даних – це випадкова адреса, яку я придумав. Це адреса пам’яті, на яку посилається змінна <code>user</code>, яка також є значенням нашого першого поля, <code>id</code>. Однак, враховуючи цю початкову адресу, усі наступні адреси мають відому відносну адресу. Оскільки "id" є 64-бітним цілим числом, воно займає 8 байт пам'яті. Тому <code>power</code> має бути на $start_address + 8:</p><pre><code>user -&gt;   ------------  (id: 1043368d0)
          |    1     |
          ------------  (power: 1043368d8)
          |   100    |
          ------------
</code></pre><p>Щоб переконатися в цьому, я хотів би ввести адресу оператора: <code>&</code>. Як випливає з назви, оператор addressof повертає адресу змінної (він також може повертати адресу функції, чи не так?!). Зберігаючи існуюче визначення <code>User</code>, спробуйте це <code>main</code>:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">user</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="number">1</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">100</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{*}\n{*}\n{*}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="operator">&</span><span class="variable">user</span><span class="punctuation delimiter">,</span> <span class="operator">&</span><span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">id</span><span class="punctuation delimiter">,</span> <span class="operator">&</span><span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Цей код друкує адресу <code>user</code>, <code>user.id</code> і <code>user.power</code>. Ви можете отримати різні результати залежно від вашої платформи та інших факторів, але, сподіваюся, ви побачите, що адреса <code>user</code> і <code>user.id</code> однакові, тоді як <code>user.power</code> має зсув у 8 байт. Я отримав:</p><pre><code>learning.User@1043368d0
u64@1043368d0
i32@1043368d8
</code></pre><p>Оператор addressof повертає покажчик на значення. Покажчик на значення є окремим типом. Адресою значення типу <code>T</code> є <code>*T</code>. Ми вимовляємо, що <i>вказівник на T</i>. Тому, якщо ми візьмемо адресу <code>user</code>, ми отримаємо <code>*User</code> або покажчик на <code>User</code>:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">user</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="number">1</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">100</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">+=</span> <span class="number">0</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">const</span> <span class="variable">user_p</span> = <span class="operator">&</span><span class="variable">user</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{any}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">user_p</span><span class="punctuation bracket">)</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Нашою початковою метою було збільшити «потужність» нашого користувача на 1 за допомогою функції «levelUp». Ми отримали код для компіляції, але коли ми надрукували <code>power</code>, це все ще було початкове значення. Це трохи стрибок, але давайте змінимо код, щоб надрукувати адресу <code>user</code> у <code>main</code> і <code>levelUp</code>:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">user</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="number">1</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">100</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">+=</span> <span class="number">0</span><span class="punctuation delimiter">;</span>

  <span class="comment">// додали це</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"main: {*}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="operator">&</span><span class="variable">user</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="variable">levelUp</span><span class="punctuation bracket">(</span><span class="variable">user</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"Користувач {d} має силу {d}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">id</span><span class="punctuation delimiter">,</span> <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword function">fn</span> <span class="function">levelUp</span><span class="punctuation bracket">(</span><span class="parameter">user</span><span class="punctuation delimiter">:</span> <span class="variable">User</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="comment">// додали це</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"levelUp: {*}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="operator">&</span><span class="variable">user</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">var</span> <span class="variable">u</span> = <span class="variable">user</span><span class="punctuation delimiter">;</span>
  <span class="variable">u</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
</figure>
<p>Якщо ви запустите це, ви отримаєте дві різні адреси. Це означає, що <code>user</code>, який змінюється в <code>levelUp</code>, відрізняється від <code>user</code> в <code>main</code>. Це відбувається тому, що Zig передає копію значення. Це може здатися дивним за замовчуванням, але одна з переваг полягає в тому, що абонент функції може бути впевнений, що функція не змінить параметр (тому що вона не може). У багатьох випадках це добре мати гарантію. Звичайно, іноді, як у випадку з <code>levelUp</code>, ми <i>хочемо</i>, щоб функція змінила параметр. Щоб досягти цього, нам потрібно, щоб <code>levelUp</code> діяв на фактичного <code>user</code> в <code>main</code>, а не на копію. Ми можемо зробити це, передавши адресу нашого користувача у функцію:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">user</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="number">1</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">100</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="comment">// більше не потрібно</span>
  <span class="comment">// user.power += 1;</span>

  <span class="comment">// user -&gt; &user</span>
  <span class="variable">levelUp</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">user</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"Користувач {d} має силу {d}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">id</span><span class="punctuation delimiter">,</span> <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="comment">// User -&gt; *User</span>
<span class="keyword function">fn</span> <span class="function">levelUp</span><span class="punctuation bracket">(</span><span class="parameter">user</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">User</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">id</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
</figure>
<p>Нам довелося внести дві зміни. Перший виклик <code>levelUp</code> з адресою користувача, тобто <code>&user</code>, замість <code>user</code>. Це означає, що наша функція більше не отримує <code>User</code>. Натомість він отримує <code>*User</code>, що було нашою другою зміною.</p><p>Нам більше не потрібен цей потворний прийом, коли користувач змушується змінюватися за допомогою <code>user.power += 0;</code>. Спочатку нам не вдалося отримати код для компіляції, оскільки <code>user</code> був <code>var</code>; компілятор сказав нам, що він ніколи не мутувався. Ми подумали, що, можливо, компілятор помилявся і «обдурив» ​​його, примусово зробивши мутацію. Але, як ми тепер знаємо, <code>user</code>, який мутував у <code>levelUp</code>, був іншим; компілятор мав рацію.</p><p>Тепер код працює належним чином. Є ще багато тонкощів із параметрами функцій і нашою моделлю пам’яті загалом, але ми просуваємося. Можливо, настав час згадати, що, окрім специфічного синтаксису, нічого з цього не є унікальним для Zig. Модель, яку ми тут досліджуємо, є найпоширенішою, деякі мови можуть просто приховати багато деталей і, отже, гнучкості від розробників.</p><h2>Методи</h2><p>Швидше за все, ви б написали <code>levelUp</code> як метод структури <code>User</code>:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">id</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>

  <span class="keyword function">fn</span> <span class="function">levelUp</span><span class="punctuation bracket">(</span><span class="parameter">user</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">User</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Це викликає запитання: як ми викликаємо метод із приймачем покажчика? Можливо, нам потрібно зробити щось на зразок: <code>&user.levelUp()</code>? Насправді, ви просто викликаєте це як зазвичай, тобто <code>user.levelUp()</code>. Zig знає, що метод очікує вказівник і передає значення правильно (за посиланням).</p><p>Спочатку я вибрав функцію, тому що вона явна і тому легше вчитися.</p><h2>Немутабельні Параметри Функції</h2><p>Я більш ніж мав на увазі, що за замовчуванням Zig передасть копію значення (називається «передача за значенням»). Незабаром ми побачимо, що реальність дещо витонченіша (підказка: як щодо складних значень із вкладеними об’єктами?)</p><p>Навіть дотримуючись простих типів, правда полягає в тому, що Zig може передавати параметри як завгодно, доки він може гарантувати збереження мети коду. У нашому оригінальному <code>levelUp</code>, де параметром був <code>User</code>, Zig міг передати копію користувача або посилання на <code>main.user</code>, якщо це могло гарантувати, що функція не змінить його. (Я знаю, що зрештою ми <i>справді</i> хотіли, щоб його змінили, але, зробивши тип <code>User</code>, ми сказали компілятору, що ми цього не зробили).</p><p>Ця свобода дозволяє Zig використовувати найбільш оптимальну стратегію на основі типу параметра. Малі типи, такі як <code>User</code>, можна дешево передати за значенням (тобто скопіювати). Більші типи може бути дешевшим передати за посиланням. Zig може використовувати будь-який підхід, за умови збереження мети коду. Певною мірою це стало можливим завдяки наявності постійних параметрів функції.</p><p>Тепер ви знаєте, що одна з причин, чому параметри функції є константами.</p><hr><blockquote><p>Можливо, вам цікаво, як передача за посиланням може бути повільнішою, навіть порівняно з копіюванням справді невеликої структури. Далі ми побачимо це більш чітко, але суть полягає в тому, що виконання <code>user.power</code>, коли <code>user</code> є вказівником, додає трохи накладних витрат. Компілятор повинен зважити вартість копіювання та вартість доступу до полів опосередковано через покажчик.</p></blockquote><hr><h2>Вказівник на Вказівник</h2><p>Раніше ми розглядали, як виглядає пам’ять <code>user</code> у нашій функції <code>main</code>. Тепер, коли ми змінили <code>levelUp</code>, як буде виглядати його пам'ять?:</p><pre><code>main:
user -&gt; ------------  (id: 1043368d0)  &lt;---
        |    1     |                      |
        ------------  (power: 1043368d8)  |
        |   100    |                      |
        ------------                      |
                                          |
        .............  пусте місце        |
        .............  або інші дані      |
                                          |
levelUp:                                  |
user -&gt; -------------  (*User)            |
        | 1043368d0 |----------------------
        -------------
</code></pre><p>У межах <code>levelUp</code> <code>user</code> є вказівником на <code>User</code>. Його значенням є адреса. Звичайно, не будь-яка адреса, а адреса <code>main.user</code>. Варто чітко сказати, що змінна <code>user</code> у <code>levelUp</code> представляє конкретне значення. Це значення є адресою. І це не <i>просто</i> адреса, це також тип, <code>*User</code>. Це все дуже узгоджено, неважливо, говоримо ми про вказівники чи ні: змінні асоціюють інформацію про тип з адресою. Єдина особливість покажчиків полягає в тому, що, коли ми використовуємо синтаксис крапки, напр. <code>user.power</code>, Zig, знаючи, що <code>user</code> є вказівником, автоматично слідуватиме за адресою.</p><hr><p>У деяких мовах для доступу до поля через вказівник потрібен інший символ.</p><hr><p>Важливо розуміти, що сама змінна <code>user</code> у <code>levelUp</code> існує в пам'яті за певною адресою. Як і раніше, ми можемо побачити це на власні очі:</p><pre><code class="zig"><span class="keyword function">fn</span> <span class="function">levelUp</span><span class="punctuation bracket">(</span><span class="parameter">user</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">User</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{*}\n{*}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="operator">&</span><span class="variable">user</span><span class="punctuation delimiter">,</span> <span class="variable">user</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Вище надруковано адресу, на яку посилається змінна <code>user</code>, а також її значення, яке є адресою <code>user</code> в <code>main</code>.</p><p>Якщо <code>user</code> є <code>*User</code>, то що таке <code>&user</code>? Це <code>**User</code> або <i>вказівник на вказівник на <code>User</code></i>. Я можу робити це, доки в одного з нас не закінчиться пам’ять!</p><p>Існує <i>є</i> варіанти використання для кількох рівнів опосередкованості, але це не те, що нам зараз потрібно. Мета цього розділу — показати, що вказівники не є чимось особливим, це просто значення, яке є адресою та типом.</p><h2>Вказівники в Структурах</h2><p>Досі наш <code>User</code> був простим і містив два цілі числа. Його пам’ять легко візуалізувати, і коли ми говоримо про «копіювання», тут немає жодної двозначності. Але що відбувається, коли <code>User</code> стає складнішим і містить вказівник?</p><pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">id</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>
  <span class="field">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Ми додали <code>name</code>, яке є фрагментом. Нагадаємо, що слайс — це довжина і покажчик. Якби ми ініціалізували нашого <code>user</code> іменем `"Goku", як би це виглядало в пам'яті?</p><pre><code>user -&gt; -------------  (id: 1043368d0)
        |     1     |
        -------------  (power: 1043368d8)
        |    100    |
        -------------  (name.len: 1043368dc)
        |     4     |
        -------------  (name.ptr: 1043368e4)
  ------| 1182145c0 |
  |     -------------
  |
  |     .............  пусте місце
  |     .............  або інші дані
  |
  ---&gt;  -------------  (1182145c0)
        |    'G'    |
        -------------
        |    'o'    |
        -------------
        |    'k'    |
        -------------
        |    'u'    |
        -------------
</code></pre><p>Нове поле <code>name</code> — це зріз, який складається з полів <code>len</code> і <code>ptr</code>. Вони розташовуються послідовно разом з усіма іншими полями. На 64-розрядній платформі і <code>len</code>, і <code>ptr</code> матимуть 64 біти, або 8 байтів. Цікавою частиною є значення <code>name.ptr</code>: це адреса до іншого місця в пам'яті.</p><hr><blockquote><p>Оскільки ми використовували рядковий літерал, <code>user.name.ptr</code> вказуватиме на конкретне місце в області, де зберігаються всі константи в нашому двійковому файлі.</p></blockquote><hr><p>З глибоким вкладенням типи можуть стати набагато складнішими. Але прості чи складні, усі вони поводяться однаково. Зокрема, якщо ми повернемося до нашого вихідного коду, де <code>levelUp</code> взяв простий <code>User</code>, а Zig надав копію, як це виглядатиме тепер, коли у нас є вкладений покажчик?</p><p>Відповідь полягає в тому, що створюється лише поверхнева копія значення. Або, як кажуть деякі, копіюється лише пам'ять, яка безпосередньо адресується змінною. Може здатися, що <code>levelUp</code> отримає недороблену копію <code>user</code>, можливо, з недійсним <code>name</code>. Але пам’ятайте, що вказівник, як-от наше <code>user.name.ptr</code>, — це значення, а це значення — адреса. Копія адреси залишається тією самою адресою:</p><pre><code>main: user -&gt;    -------------  (id: 1043368d0)
                 |     1     |
                 -------------  (power: 1043368d8)
                 |    100    |
                 -------------  (name.len: 1043368dc)
                 |     4     |
                 -------------  (name.ptr: 1043368e4)
                 | 1182145c0 |-------------------------
levelUp: user -&gt; -------------  (id: 1043368ec)       |
                 |     1     |                        |
                 -------------  (power: 1043368f4)    |
                 |    100    |                        |
                 -------------  (name.len: 1043368f8) |
                 |     4     |                        |
                 -------------  (name.ptr: 104336900) |
                 | 1182145c0 |-------------------------
                 -------------                        |
                                                      |
                 .............  пусте місце           |
                 .............  або інші дані         |
                                                      |
                 -------------  (1182145c0)        &lt;---
                 |    'G'    |
                 -------------
                 |    'o'    |
                 -------------
                 |    'k'    |
                 -------------
                 |    'u'    |
                 -------------
</code></pre><p>З вищесказаного ми бачимо, що неглибоке копіювання буде працювати. Оскільки значення вказівника є адресою, копіювання значення означає, що ми отримуємо ту саму адресу. Це має важливі наслідки щодо мінливості. Наша функція не може змінювати поля, до яких безпосередньо звертається <code>main.user</code>, оскільки вона отримала копію, але вона має доступ до того самого <code>name</code>, тож чи може вона змінити це? У цьому конкретному випадку ні, <code>name</code> є <code>const</code>. Крім того, наше значення «Goku» — це рядковий літерал, який завжди є незмінним. Але, трохи попрацювавши, ми можемо побачити наслідки поверхневого копіювання:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">name</span> = <span class="punctuation bracket">[</span><span class="number">4</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span><span class="punctuation bracket">{</span><span class="character">'G'</span><span class="punctuation delimiter">,</span> <span class="character">'o'</span><span class="punctuation delimiter">,</span> <span class="character">'k'</span><span class="punctuation delimiter">,</span> <span class="character">'u'</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">user</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="number">1</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">100</span><span class="punctuation delimiter">,</span>
    <span class="comment">// розрізали це, [4]u8 -&gt; []u8</span>
    <span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="variable">name</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation special">..</span><span class="punctuation bracket">]</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="variable">levelUp</span><span class="punctuation bracket">(</span><span class="variable">user</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{s}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">name</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword function">fn</span> <span class="function">levelUp</span><span class="punctuation bracket">(</span><span class="parameter">user</span><span class="punctuation delimiter">:</span> <span class="variable">User</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">name</span><span class="punctuation bracket">[</span><span class="number">2</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="character">'!'</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">id</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>
  <span class="comment">// []const u8 -&gt; []u8</span>
  <span class="field">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
</figure>
<p>Наведений вище код друкує "Go!u". Нам довелося змінити тип <code>name</code> з <code>[]const u8</code> на <code>[]u8</code> і замість рядкового літералу, який завжди є незмінним, створити масив і розділити його. Дехто може побачити тут невідповідність. Передача за значенням запобігає зміні функції безпосередніх полів, але не полів зі значенням за вказівником. Якщо ми <i>хотіли</i>, щоб <code>name</code> було незмінним, ми повинні були оголосити його як <code>[]const u8</code> замість <code>[]u8</code>.</p><p>Деякі мови мають іншу реалізацію, але багато мов працюють саме так (або дуже близько). Незважаючи на те, що все це може здатися езотерикою, це фундаментальне значення для повсякденного програмування. Хороша новина полягає в тому, що ви можете освоїти це, використовуючи прості приклади та фрагменти; вона не стає складнішою, оскільки інші частини системи стають все більш складними.</p><h2>Рекурсивні Структури</h2><p>Іноді потрібна рекурсивна структура. Зберігаючи наш існуючий код, давайте додамо необов’язковий <code>manager</code> типу <code>?User</code> до нашого <code>User</code>. Поки ми на цьому, ми створимо двох <code>User</code> і призначимо одного менеджером іншому:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">leto</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="number">1</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">9001</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">manager</span> = <span class="constant builtin">null</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">const</span> <span class="variable">duncan</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="number">1</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">9001</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">manager</span> = <span class="variable">leto</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{any}\n{any}"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">leto</span><span class="punctuation delimiter">,</span> <span class="variable">duncan</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">id</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>
  <span class="field">manager</span><span class="punctuation delimiter">:</span> <span class="operator">?</span><span class="variable">User</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
</figure>
<p>Цей код не компілюється: <i>struct 'learning.User' depends on itself</i>. Це не вдається, тому що кожен тип повинен мати відомий розмір під час компіляції.</p><p>Ми не зіткнулися з цією проблемою, коли додали <code>name</code>, хоча імена можуть мати різну довжину. Проблема не в розмірі значень, а в розмірі самих типів. Zig потребує цих знань, щоб робити все, про що ми говорили вище, наприклад, отримати доступ до поля на основі його положення зсуву. <code>name</code> був фрагментом, <code>[]const u8</code>, і він має відомий розмір: 16 байтів - 8 байтів для <code>len</code> і 8 байтів для <code>ptr</code>.</p><p>Ви можете подумати, що це буде проблемою з будь-яким необов’язковим або об’єднанням. Але як для опцій, так і для об’єднань відомий найбільший можливий розмір, і Zig може його використати. Рекурсивна структура не має такої верхньої межі, структура може рекурсувати один, два або мільйони разів. Це число змінюватиметься від <code>User</code> до <code>User</code> і не буде відоме під час компіляції.</p><p>Ми бачили відповідь із <code>name</code>: використовувати вказівник. Покажчики завжди приймають байти <code>usize</code>. На 64-розрядній платформі це 8 байт. Подібно до того, як фактичне ім’я «Goku» не зберігалося разом із нашим <code>user</code>, використання вказівника означає, що наш менеджер більше не прив’язаний до макета пам’яті <code>user</code>.</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">leto</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="number">1</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">9001</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">manager</span> = <span class="constant builtin">null</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">const</span> <span class="variable">duncan</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="number">1</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">9001</span><span class="punctuation delimiter">,</span>
    <span class="comment">// змінили leto -&gt; &leto</span>
    <span class="punctuation delimiter">.</span><span class="field">manager</span> = <span class="operator">&</span><span class="variable">leto</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{any}\n{any}"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">leto</span><span class="punctuation delimiter">,</span> <span class="variable">duncan</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">id</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>
  <span class="comment">// змінили ?const User -&gt; ?*const User</span>
  <span class="field">manager</span><span class="punctuation delimiter">:</span> <span class="operator">?</span><span class="operator">*</span><span class="type qualifier">const</span> <span class="variable">User</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
</figure>
<p>Вам може ніколи не знадобитися рекурсивна структура, але це не про моделювання даних. Йдеться про розуміння покажчиків і моделей пам’яті, а також про краще розуміння того, що збирає компілятор.</p><hr><p>Багато розробників борються з покажчиками, у них може бути щось невловиме. Вони не здаються конкретними, як ціле число, рядок або <code>User</code>. Нічого з цього не повинно бути кристально зрозумілим, щоб ви рухалися вперед. Але це варто освоїти, і не тільки для Zig. Ці деталі можуть бути приховані в таких мовах, як Ruby, Python і JavaScript, і меншою мірою в C#, Java і Go, але вони все ще присутні, впливаючи на те, як ви пишете код і як цей код виконується. Тож не поспішайте, пограйте з прикладами, додайте оператори друку налагодження, щоб переглянути змінні та їх адресу. Чим більше ви досліджуєте, тим ясніше стане.</p></div>
	
      </div>
    </div>
  </div>
</body>

</html>