<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <meta name="description" content="Вивчаємо Zig Українською. Zig — імперативна, статично типізована, компільована системна мова програмування загального призначення.">
    <meta property="og:title" content="Програмуємо мовою Zig">
    <meta property="og:type" content="website">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      Програмуємо мовою Zig
      Вивчаємо Zig Українською
    </title>
    <link rel="stylesheet" type="text/css" href="/learning-zig-ukr/style.css">
    <link rel="stylesheet" type="text/css" href="/learning-zig-ukr/highlight.css">
    
  </head>
  <body>
    <header>
      <h1>Вивчаємо Zig Українською</h1>
    </header>
    <div id="main-wrapper">
      <div id="navigation">
        <nav aria-labelledby="table-of-contents">
          <h2 id="table-of-contents">Зміст</h2>
          <ul>
            <li><a id="toc-Index" href="/learning-zig-ukr/">Вступ</a></li>
            <li><a id="toc-Language-Overview-1" href="/learning-zig-ukr/language-overview-1/">Огляд Мови, частина 1</a></li>
            <li><a id="toc-Language-Overview-2" href="/learning-zig-ukr/language-overview-2/">Огляд Мови, частина 2</a></li>
            <li><a id="toc-Style-Guide" href="/learning-zig-ukr/style-guide/">Керівництво по стилю оформлення</a></li>
            <li><a id="toc-Pointers" href="/learning-zig-ukr/pointers/">Вказівники</a></li>
            <li><a id="toc-Stack-Memory" href="/learning-zig-ukr/stack-memory/">Стекова пам'ять</a></li>
            <li><a id="toc-Heap-Memory" href="/learning-zig-ukr/heap-memory/">Динамічна пам'ять та розподільники пам'яті</a></li>
            <li><a id="toc-Generics" href="/learning-zig-ukr/generics/">Узагальнені структури даних</a></li>
            <li><a id="toc-Coding-In-Zig" href="/learning-zig-ukr/coding-in-zig/">Програмуємо мовою Zig</a></li>
            <li><a id="toc-Conclusion" href="/learning-zig-ukr/conclusion/">Висоновки</a></li>
          </ul>
        </nav>
      </div>
      <div id="contents-wrapper">
        <div id="contents">
          
		<h1 var="Програмуємо мовою Zig"></h1>
		<div id="docs"><p>У зв’язку з тим, що ми вже охопили більшу частину мови, ми збираємося закінчити, переглянувши кілька тем і розглянувши ще кілька практичних аспектів використання Zig. При цьому ми збираємося представити більше стандартної бібліотеки та представити менш тривіальні фрагменти коду.</p><h2>Знову "Висячі" вказівники</h2><p>Ми починаємо з розгляду інших прикладів висячих покажчиків. Це може здатися дивною річчю, на якій варто зосередитися, але якщо ви походите з мови, яка збирає сміття, це, мабуть, найбільша проблема, з якою ви зіткнетеся.</p><p>Чи можете ви зрозуміти, що це за наступні результати?</p><div class="block"><p></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
 <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
 <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

 <span class="type qualifier">var</span> <span class="variable">lookup</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="function">StringHashMap</span><span class="punctuation bracket">(</span><span class="variable">User</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
 <span class="keyword">defer</span> <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

 <span class="type qualifier">const</span> <span class="variable">goku</span> = <span class="variable">User</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">9001</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

 <span class="operator">try</span> <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">put</span><span class="punctuation bracket">(</span><span class="string">&quot;Goku&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">goku</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

 <span class="comment">// повертаємо опціональне значення, .? запанікує якщо &quot;Goku&quot;</span>
 <span class="comment">// немає в хещ-мапі</span>
 <span class="type qualifier">const</span> <span class="variable">entry</span> = <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">getPtr</span><span class="punctuation bracket">(</span><span class="string">&quot;Goku&quot;</span><span class="punctuation bracket">)</span><span class="operator">.?</span><span class="punctuation delimiter">;</span>

 <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Goku&apos;s power is: {d}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">entry</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

 <span class="comment">// повертає true/false в залежності від того чи був елемент видалений</span>
 <span class="variable">_</span> <span class="operator">=</span> <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">remove</span><span class="punctuation bracket">(</span><span class="string">&quot;Goku&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

 <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Сила Goku становить: {d}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">entry</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
 <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
</div><p>Коли я це запустив, я отримав</p><pre><code>Сила Goku становить: 9001
Сила Goku становить: -1431655766
</code></pre><p>Цей код представляє загальний <code>std.StringHashMap</code> Zig, який є спеціалізованою версією <code>std.AutoHashMap</code> з типом ключа, встановленим як <code>[]const u8</code>. Навіть якщо ви не на 100% впевнені, що відбувається, можна припустити, що мій висновок стосується того факту, що наш другий <code>print</code> відбувається після того, як ми <code>remove</code> запис із <code>lookup</code>. Закоментуйте виклик <code>remove</code>, і результат буде нормальним.</p><p>Ключ до розуміння наведеного вище коду полягає в тому, щоб знати, де існують дані/пам’ять, або, іншими словами, хто ними _володіє. Пам’ятайте, що аргументи Zig передаються за значенням, тобто ми передаємо [не глибоку] копію значення. «Користувач» у нашому «пошуку» не є тією самою пам’яттю, на яку посилається «goku». Наш наведений вище код має <strong>двох</strong> користувачів, кожен зі своїм власником. <code>goku</code> належить <code>main</code>, а його копія належить <code>lookup</code>.</p><p>Метод <code>getPtr</code> повертає вказівник на значення в карті, у нашому випадку він повертає <code>*User</code>. Ось у чому полягає проблема, <code>remove</code> робить наш вказівник <code>entry</code> недійсним. У цьому прикладі близькість <code>getPtr</code> і <code>remove</code> робить проблему дещо очевидною. Але неважко уявити код, що викликає <code>remove</code>, не знаючи, що посилання на запис міститься десь в іншому місці.</p><hr><blockquote><p>Коли я писав цей приклад, я не був упевнений, що станеться. Можна було реалізувати <code>remove</code> шляхом встановлення внутрішнього прапора, відкладаючи фактичне видалення до наступної події. Якби це було так, вищесказане могло б «спрацювати» в наших простих випадках, але не вдалося б із більш складним використанням. Це звучить жахливо важко налагодити.</p></blockquote><hr><p>Крім того, що ми не викликаємо <code>remove</code>, ми можемо виправити це кількома різними способами. По-перше, ми можемо використовувати <code>get</code> замість <code>getPtr</code>. Це повертатиме <code>User</code> замість <code>*User</code> і таким чином повертатиме копію значення в <code>lookup</code>. Тоді у нас буде три <code>User</code>.</p><ol><li>Наш оригінальний <code>goku</code>, прив'язаний до функції.</li><li>Копія в <code>lookup</code>, яка належить пошуку.</li><li>І копія нашої копії, <code>entry</code>, також прив’язана до функції.</li></ol><p>Оскільки <code>entry</code> тепер буде власною незалежною копією користувача, видалення його з <code>lookup</code> не призведе до недійсності.</p><p>Інший варіант – змінити тип пошуку з <code>StringHashMap(User)</code> на <code>StringHashMap(*const User)</code>. Цей код працює:</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// User -&gt; *const User</span>
  <span class="type qualifier">var</span> <span class="variable">lookup</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="function">StringHashMap</span><span class="punctuation bracket">(</span><span class="operator">*</span><span class="type qualifier">const</span> <span class="variable">User</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword">defer</span> <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">const</span> <span class="variable">goku</span> = <span class="variable">User</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">9001</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="comment">// goku -&gt; &goku</span>
  <span class="operator">try</span> <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">put</span><span class="punctuation bracket">(</span><span class="string">&quot;Goku&quot;</span><span class="punctuation delimiter">,</span> <span class="operator">&</span><span class="variable">goku</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// getPtr -&gt; get</span>
  <span class="type qualifier">const</span> <span class="variable">entry</span> = <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">get</span><span class="punctuation bracket">(</span><span class="string">&quot;Goku&quot;</span><span class="punctuation bracket">)</span><span class="operator">.?</span><span class="punctuation delimiter">;</span>

  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Сила Goku становить: {d}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">entry</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">_</span> <span class="operator">=</span> <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">remove</span><span class="punctuation bracket">(</span><span class="string">&quot;Goku&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Сила Goku становить: {d}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">entry</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>У наведеному вище коді є ряд тонкощів. По-перше, тепер у нас є єдиний <code>User</code>, <code>goku</code>. Значення в <code>lookup</code> і <code>entry</code> є посиланнями на <code>goku</code>. Наш виклик <code>remove</code> все одно видаляє значення з нашого <code>lookup</code>, але це значення є просто адресою <code>user</code>, це не є <code>user</code> сам по собі. Якби ми зупинилися на <code>getPtr</code>, ми отримали б недійсний <code>**User</code>, недійсний через <code>remove</code>. В обох рішеннях ми мали використовувати <code>get</code> замість <code>getPtr</code>, але в цьому випадку ми просто копіюємо адресу, а не повний <code>User</code>. Для великих об’єктів це може бути значною різницею.</p><p>Оскільки все в одній функції та невеликому значенні, як-от <code>User</code>, це все ще виглядає як штучно створена проблема. Нам потрібен приклад, який законно робить право власності на дані негайною проблемою.</p><h2>Володіння</h2><p>Мені подобаються хеш-карти, тому що це те, що всі знають і користуються ними. Вони також мають багато різних варіантів використання, більшість із яких ви, ймовірно, стикалися з перших рук. Хоча їх можна використовувати як короткочасні пошуки, вони часто довгоживуть і, отже, вимагають настільки ж довготривалих значень.</p><p>Цей код заповнює наш <code>lookup</code> іменами, які ви вводите в терміналі. Порожнє ім'я зупиняє цикл підказки. Нарешті, він визначає, чи було <code>Leto</code> одним із наданих імен.</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">builtin</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;builtin&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">lookup</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="function">StringHashMap</span><span class="punctuation bracket">(</span><span class="variable">User</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword">defer</span> <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// stdin це std.io.Reader</span>
  <span class="comment">// і протидежний std.io.Writer, який ми вже бачили</span>
  <span class="type qualifier">const</span> <span class="variable">stdin</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">io</span><span class="punctuation delimiter">.</span><span class="function">getStdIn</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">reader</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// stdout це std.io.Writer</span>
  <span class="type qualifier">const</span> <span class="variable">stdout</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">io</span><span class="punctuation delimiter">.</span><span class="function">getStdOut</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">writer</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">i</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span> = <span class="number">0</span><span class="punctuation delimiter">;</span>
  <span class="repeat">while</span> <span class="punctuation bracket">(</span><span class="boolean">true</span><span class="punctuation bracket">)</span> <span class="punctuation delimiter">:</span> <span class="punctuation bracket">(</span><span class="variable">i</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
    <span class="type qualifier">var</span> <span class="variable">buf</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="number">30</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span> = <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
    <span class="operator">try</span> <span class="variable">stdout</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Будь ласка, введіть імʼя: &quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="operator">try</span> <span class="variable">stdin</span><span class="punctuation delimiter">.</span><span class="function">readUntilDelimiterOrEof</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">buf</span><span class="punctuation delimiter">,</span> <span class="character">&apos;\n&apos;</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">|line|</span> <span class="punctuation bracket">{</span>
      <span class="type qualifier">var</span> <span class="variable">name</span> = <span class="variable">line</span><span class="punctuation delimiter">;</span>
      <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">builtin</span><span class="punctuation delimiter">.</span><span class="field">os</span><span class="punctuation delimiter">.</span><span class="field">tag</span> <span class="operator">==</span> <span class="punctuation delimiter">.</span><span class="variable builtin">windows</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
        <span class="comment">// У Windows рядки закінчуються на\r\n.</span>
        <span class="comment">// Нам потрібно прибрати \r</span>
        <span class="variable">name</span> <span class="operator">=</span> <span class="function builtin">@constCast</span><span class="punctuation bracket">(</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="function">trimRight</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="variable">name</span><span class="punctuation delimiter">,</span> <span class="string">&quot;\r&quot;</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
      <span class="punctuation bracket">}</span>
      <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">name</span><span class="punctuation delimiter">.</span><span class="field">len</span> <span class="operator">==</span> <span class="number">0</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
        <span class="repeat">break</span><span class="punctuation delimiter">;</span>
      <span class="punctuation bracket">}</span>
      <span class="operator">try</span> <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">put</span><span class="punctuation bracket">(</span><span class="variable">name</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="variable">i</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
  <span class="punctuation bracket">}</span>

  <span class="type qualifier">const</span> <span class="variable">has_leto</span> = <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">contains</span><span class="punctuation bracket">(</span><span class="string">&quot;Leto&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;{any}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">has_leto</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="punctuation bracket">}</span>

<span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<hr><blockquote><p>Початкова версія цього коду не компілюється в Windows. Потрібно було додати <code>@constCast</code>, який ви зараз бачите. Ми бачили інші вбудовані функції, але ця є більш просунутою. Я обмірковував видалення всього рядка, але я хотів, щоб люди могли слідкувати за цим у Windows, і тому потребував обрізки. Для цього випадку були простіші рішення, але замість цього я вирішив дотримуватися небезпечного <code>@constCast</code>. Я написав допис у блозі на основі цього прикладу, який пояснює, чому він потрібний, але він є значно складнішим. Це те, до чого ви, можливо, захочете повернутися, провівши більше часу із Зігом</p></blockquote><hr><p>Код чутливий до регістру, але незалежно від того, наскільки ідеально ми вводимо "Leto", <code>contains</code> завжди повертає <code>false</code>. Давайте виправимо це, повторивши <code>lookup</code> і викинувши ключі та значення:</p><pre><code class="zig"><span class="comment">// Розмістіть цей код після циклу while</span>

<span class="type qualifier">var</span> <span class="variable">it</span> = <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">iterator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="repeat">while</span> <span class="punctuation bracket">(</span><span class="variable">it</span><span class="punctuation delimiter">.</span><span class="function">next</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">|kv|</span><span class="keyword"></span> <span class="punctuation bracket">{</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;{s} == {any}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">kv</span><span class="punctuation delimiter">.</span><span class="field">key_ptr</span><span class="punctuation delimiter">.</span><span class="field">_</span><span class="punctuation delimiter">,</span> <span class="variable">kv</span><span class="punctuation delimiter">.</span><span class="field">value_ptr</span><span class="punctuation delimiter">.</span><span class="field">_</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="error">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Цей шаблон ітератора поширений у Zig і ґрунтується на синергії між типами <code>while</code> і необов’язковими. Наш елемент ітератора повертає вказівники на наш ключ і значення, тому ми розіменовуємо їх за допомогою <code>.*</code>, щоб отримати доступ до фактичного значення, а не до адреси. Результат залежатиме від того, що ви введете, але я отримав:</p><pre><code>Будь ласка, введіть імʼя: Paul
Будь ласка, введіть імʼя: Teg
Будь ласка, введіть імʼя: Leto
Будь ласка, введіть імʼя:

�� == learning.User{ .power = 1 }

��� == learning.User{ .power = 0 }

��� == learning.User{ .power = 2 }
false
</code></pre><p>Значення виглядають добре, але не ключі. Якщо ви не впевнені, що відбувається, можливо, це моя вина. Раніше я навмисно перевернув вашу увагу. Я сказав, що хеш-карти часто довгоживуть і тому вимагають довгоживучих <em>значень</em>. Правда полягає в тому, що вони вимагають довготривалих значень <strong>а також</strong> довгоживучих ключів! Зверніть увагу, що <code>buf</code> визначено всередині нашого циклу <code>while</code>. Коли ми викликаємо <code>put</code>, ми надаємо нашій хеш-карті ключ, який має набагато коротший час життя, ніж сама хеш-карта. Переміщення <code>buf</code> <em>поза</em> циклу <code>while</code> вирішує нашу проблему тривалості життя, але цей буфер повторно використовується в кожній ітерації. Це все одно не працюватиме, оскільки ми змінюємо базові ключові дані.</p><p>Для нашого вищенаведеного коду насправді є лише одне рішення: наш <code>пошук</code> має взяти на себе право власності на ключі. Нам потрібно додати один рядок і змінити інший:</p><pre><code class="zig"><span class="comment">// замініть існуючий lookup.put цими двома рядками</span>
<span class="type qualifier">const</span> <span class="variable">owned_name</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">dupe</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="variable">name</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="comment">// name -&gt; owned_name</span>
<span class="variable">try</span> <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">put</span><span class="punctuation bracket">(</span><span class="variable">owned_name</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="variable">i</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p><code>dupe</code> — це метод <code>std.mem.Allocator</code>, якого ми раніше не бачили. Він виділяє дублікат заданого значення. Код тепер працює, тому що наші ключі, які тепер знаходяться в купі, переживають <code>lookup</code>. Насправді ми надто добре подовжили термін служби цих рядків: ми запровадили витоки пам’яті.</p><p>Ви могли подумати, що коли ми викликаємо <code>lookup.deinit</code>, наші ключі та значення будуть звільнені для нас. Але немає універсального рішення, яке б міг використовувати <code>StringHashMap</code>. По-перше, ключі можуть бути рядковими літералами, які не можна звільнити. По-друге, вони могли бути створені з іншим розподільником. Нарешті, хоча й більш просунутий, існують законні випадки, коли ключі можуть не належати хеш-карті.</p><p>Єдине рішення — звільнити ключі самостійно. На цьому етапі, ймовірно, буде сенс створити наш власний тип UserLookup і інкапсулювати цю логіку очищення в нашу функцію deinit. Ми будемо тримати все безладно:</p><pre><code class="zig"><span class="comment">// замініть існуючий</span>
<span class="comment">// defer lookup.deinit();</span>
<span class="comment">// цим:</span>
<span class="label">defer</span><span class="punctuation delimiter"></span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">it</span> = <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">keyIterator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="repeat">while</span> <span class="punctuation bracket">(</span><span class="variable">it</span><span class="punctuation delimiter">.</span><span class="function">next</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">|key|</span> <span class="punctuation bracket">{</span>
    <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">key</span><span class="operator">.*</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>
  <span class="variable">lookup</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Наша логіка <code>defer</code>, перша, яку ми бачили з блоком, звільняє кожен ключ, а потім деініціалізує <code>lookup</code>. Ми використовуємо <code>keyIterator</code> лише для ітерації ключів. Значення ітератора є покажчиком на ключовий запис у хеш-карті, <code>_[]const u8</code>. Ми хочемо звільнити фактичне значення, оскільки це те, що ми виділили за допомогою <code>dupe</code>, тому ми розіменовуємо значення за допомогою <code>._</code>.</p><p>Обіцяю, ми закінчили говорити про висячі покажчики та керування пам’яттю. Те, що ми обговорювали, може бути незрозумілим або надто абстрактним. Добре повернутися до цього, коли у вас є більш практична проблема для вирішення. Тим не менш, якщо ви плануєте написати щось нетривіальне, це те, що вам майже напевно доведеться освоїти. Коли ви почуваєтесь готові до цього, я закликаю вас взяти приклад циклу підказок і пограти з ним самостійно. Представте тип <code>UserLookup</code>, який інкапсулює все керування пам’яттю, яке нам потрібно було зробити. Спробуйте використовувати значення <code>*User</code> замість <code>User</code>, створюючи користувачів у купі та звільняючи їх, як ми робили ключі. Напишіть тести, які охоплюють вашу нову структуру, використовуючи <code>std.testing.allocator</code>, щоб переконатися, що ви не втрачаєте пам’ять.</p><h2>Динамічний масив <code>ArrayList</code></h2><p>Ви будете раді знати, що можете забути про наш <code>IntList</code> і загальну альтернативу, яку ми створили. Zig має правильну реалізацію динамічного масиву: <code>std.ArrayList(T)</code>.</p><p>Це досить стандартна річ, але це настільки поширена і використовувана структура даних, що варто побачити її в дії:</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">builtin</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;builtin&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">Allocator</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="field">Allocator</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">arr</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="function">ArrayList</span><span class="punctuation bracket">(</span><span class="variable">User</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword">defer</span> <span class="punctuation bracket">{</span>
    <span class="repeat">for</span> <span class="punctuation bracket">(</span><span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">)</span> |<span class="variable">user</span>| <span class="punctuation bracket">{</span>
      <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
    <span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>

  <span class="type qualifier">const</span> <span class="variable">stdin</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">io</span><span class="punctuation delimiter">.</span><span class="function">getStdIn</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">reader</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">const</span> <span class="variable">stdout</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">io</span><span class="punctuation delimiter">.</span><span class="function">getStdOut</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">writer</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">i</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span> = <span class="number">0</span><span class="punctuation delimiter">;</span>
  <span class="repeat">while</span> <span class="punctuation bracket">(</span><span class="boolean">true</span><span class="punctuation bracket">)</span> <span class="punctuation delimiter">:</span> <span class="punctuation bracket">(</span><span class="variable">i</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
    <span class="type qualifier">var</span> <span class="variable">buf</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="number">30</span><span class="punctuation bracket">]</span><span class="type builtin">u8</span> = <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
    <span class="operator">try</span> <span class="variable">stdout</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;Будь ласка, введіть імʼя: &quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="operator">try</span> <span class="variable">stdin</span><span class="punctuation delimiter">.</span><span class="function">readUntilDelimiterOrEof</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">buf</span><span class="punctuation delimiter">,</span> <span class="character">&apos;\n&apos;</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">|line|</span> <span class="punctuation bracket">{</span>
    <span class="type qualifier">var</span> <span class="variable">name</span> = <span class="variable">line</span><span class="punctuation delimiter">;</span>
    <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">builtin</span><span class="punctuation delimiter">.</span><span class="field">os</span><span class="punctuation delimiter">.</span><span class="field">tag</span> <span class="operator">==</span> <span class="punctuation delimiter">.</span><span class="variable builtin">windows</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
      <span class="variable">name</span> <span class="operator">=</span> <span class="function builtin">@constCast</span><span class="punctuation bracket">(</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="function">trimRight</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="variable">name</span><span class="punctuation delimiter">,</span> <span class="string">&quot;\r&quot;</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
    <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">name</span><span class="punctuation delimiter">.</span><span class="field">len</span> <span class="operator">==</span> <span class="number">0</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
      <span class="repeat">break</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
    <span class="type qualifier">const</span> <span class="variable">owned_name</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">dupe</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="variable">name</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="operator">try</span> <span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="function">append</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="variable">owned_name</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="variable">i</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
  <span class="punctuation bracket">}</span>

  <span class="type qualifier">var</span> <span class="variable">has_leto</span> = <span class="boolean">false</span><span class="punctuation delimiter">;</span>
  <span class="repeat">for</span> <span class="punctuation bracket">(</span><span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">)</span> |<span class="variable">user</span>| <span class="punctuation bracket">{</span>
    <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="function">eql</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="string">&quot;Leto&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">name</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
      <span class="variable">has_leto</span> <span class="operator">=</span> <span class="boolean">true</span><span class="punctuation delimiter">;</span>
      <span class="repeat">break</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
  <span class="punctuation bracket">}</span>

  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;{any}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">has_leto</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="punctuation bracket">}</span>

<span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">i32</span><span class="punctuation delimiter">,</span>

  <span class="keyword function">fn</span> <span class="function">deinit</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="variable">User</span><span class="punctuation delimiter">,</span> <span class="parameter">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">name</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Вище наведено відтворення нашого коду хеш-карти, але з використанням <code>ArrayList(User)</code>. Застосовуються ті самі правила керування терміном служби та пам’яттю. Зауважте, що ми все ще створюємо <code>дуп</code> імені, і ми все ще звільняємо кожне ім’я перед тим, як <code>деінітувати</code> <code>ArrayList</code>.</p><p>Це гарний момент, щоб зазначити, що Zig не має властивостей або приватних полів. Ви можете побачити це, коли ми отримуємо доступ до <code>arr.items</code>, щоб перебирати значення. Причиною відсутності властивостей є усунення джерела сюрпризів. У Zig, якщо це виглядає як доступ до поля, це <strong>є</strong> доступ до поля. Особисто я вважаю, що відсутність приватних полів є помилкою, але це, звичайно, те, що ми можемо обійти. Я додав до полів префікс підкресленням, щоб позначити «тільки для внутрішнього використання».</p><p>Оскільки «тип» рядка є <code>[]u8</code> або <code>[]const u8</code>, <code>ArrayList(u8)</code> є відповідним типом для конструктора рядків, наприклад <code>StringBuilder</code> .NET або <code>strings.Builder</code> Go's . Фактично, ви часто будете використовувати це, коли функція приймає <code>Writer</code>, а вам потрібен рядок. Раніше ми бачили приклад використання <code>std.json.stringify</code> для виведення JSON на stdout. Ось як можна використати <code>ArrayList(u8)</code> для виведення його в змінну:</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">out</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="function">ArrayList</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword">defer</span> <span class="variable">out</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="operator">try</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">json</span><span class="punctuation delimiter">.</span><span class="function">stringify</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">this_is</span> = <span class="string">&quot;an anonymous struct&quot;</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">above</span> = <span class="boolean">true</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">last_param</span> = <span class="string">&quot;are options&quot;</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">whitespace</span> = <span class="punctuation delimiter">.</span><span class="variable builtin">indent_2</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span> <span class="variable">out</span><span class="punctuation delimiter">.</span><span class="function">writer</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;{s}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">out</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<h2><code>Anytype</code></h2><p>У частині 1 ми коротко говорили про <code>anytype</code>. Це досить корисна форма качиного введення під час компіляції. Ось простий реєстратор:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">Logger</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">level</span><span class="punctuation delimiter">:</span> <span class="variable">Level</span><span class="punctuation delimiter">,</span>

  <span class="comment">// &quot;error&quot; зарезервовано, імена в середині @&quot;...&quot; завжди</span>
  <span class="comment">// використовуються як ідентифікатори</span>
  <span class="type qualifier">const</span> <span class="variable">Level</span> = <span class="keyword">enum</span> <span class="punctuation bracket">{</span>
    <span class="variable">debug</span><span class="punctuation delimiter">,</span>
    <span class="variable">info</span><span class="punctuation delimiter">,</span>
    <span class="variable">@&quot;error&quot;</span><span class="punctuation delimiter">,</span>
    <span class="variable">fatal</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="keyword function">fn</span> <span class="function">info</span><span class="punctuation bracket">(</span><span class="parameter">logger</span><span class="punctuation delimiter">:</span> <span class="variable">Logger</span><span class="punctuation delimiter">,</span> <span class="parameter">msg</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="parameter">out</span><span class="punctuation delimiter">:</span> <span class="type builtin">anytype</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="function builtin">@intFromEnum</span><span class="punctuation bracket">(</span><span class="variable">logger</span><span class="punctuation delimiter">.</span><span class="field">level</span><span class="punctuation bracket">)</span> <span class="operator">&lt;=</span> <span class="function builtin">@intFromEnum</span><span class="punctuation bracket">(</span><span class="variable">Level</span><span class="punctuation delimiter">.</span><span class="field">info</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
      <span class="operator">try</span> <span class="variable">out</span><span class="punctuation delimiter">.</span><span class="function">writeAll</span><span class="punctuation bracket">(</span><span class="variable">msg</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
  <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Параметр <code>out</code> нашої функції <code>info</code> має тип <code>anytype</code>. Це означає, що наш <code>Logger</code> може реєструвати повідомлення до будь-якої структури, яка має метод <code>writeAll</code>, який приймає <code>[]const u8</code> і повертає <code>!void</code>. Це не функція часу виконання. Перевірка типів відбувається під час компіляції, і для кожного використаного типу створюється правильно введена функція. Якщо ми спробуємо викликати <code>info</code> з типом, який не має всіх необхідних функцій (у цьому випадку просто <code>writeAll</code>), ми отримаємо помилку часу компіляції:</p><pre><code class="zig"><span class="type qualifier">var</span> <span class="variable">l</span> = <span class="variable">Logger</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">level</span> = <span class="punctuation delimiter">.</span><span class="variable builtin">info</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="variable">try</span> <span class="variable">l</span><span class="punctuation delimiter">.</span><span class="function">info</span><span class="punctuation bracket">(</span><span class="string">&quot;сервер запущено&quot;</span><span class="punctuation delimiter">,</span> <span class="boolean">true</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>Надає нам: <em>no field or member function named 'writeAll' in 'bool'</em>.. Використання <code>writer</code> <code>ArrayList(u8)</code> працює:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">l</span> = <span class="variable">Logger</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">level</span> = <span class="punctuation delimiter">.</span><span class="variable builtin">info</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">arr</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="function">ArrayList</span><span class="punctuation bracket">(</span><span class="type builtin">u8</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword">defer</span> <span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="operator">try</span> <span class="variable">l</span><span class="punctuation delimiter">.</span><span class="function">info</span><span class="punctuation bracket">(</span><span class="string">&quot;скрвер запущено&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="function">writer</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">&quot;{s}\n&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Одним із значних недоліків <code>anytype</code> є документація. Ось підпис для функції <code>std.json.stringify</code>, яку ми використовували кілька разів:</p><pre><code class="zig"><span class="comment">// Я **ненавиджу** багаторядкові визначення функцій</span>
<span class="comment">// Але я зроблю виняток для посібника, який</span>
<span class="comment">// можливо, ви читаєте на маленькому екрані.</span>

<span class="keyword function">fn</span> <span class="function">stringify</span><span class="punctuation bracket">(</span>
  <span class="parameter">value</span><span class="punctuation delimiter">:</span> <span class="type builtin">anytype</span><span class="punctuation delimiter">,</span>
  <span class="parameter">options</span><span class="punctuation delimiter">:</span> <span class="variable">StringifyOptions</span><span class="punctuation delimiter">,</span>
  <span class="parameter">out_stream</span><span class="punctuation delimiter">:</span> <span class="type builtin">anytype</span>
<span class="punctuation bracket">)</span> <span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">out_stream</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="field">Error</span><span class="exception">!</span><span class="type builtin">void</span>
</code></pre>
<p>Перший параметр, <code>value: anytype</code> начебто очевидний. Це значення для серіалізації, і воно може бути будь-яким (насправді є деякі речі, які JSON-серіалізатор Zig не може серіалізувати). Ми можемо здогадатися, що <code>out_stream</code> є <em>де</em> для запису JSON, але ваші припущення такі ж хороші, як і мої щодо методів, які потрібно реалізувати. Єдиний спосіб зрозуміти це — прочитати вихідний код або, альтернативно, передати фіктивне значення та використати помилки компілятора як нашу документацію. Це те, що можна покращити за допомогою кращих автоматичних генераторів документів. Але не вперше я хотів би, щоб Zig мав інтерфейси.</p><h2><code>@TypeOf</code></h2><p>У попередніх частинах ми використовували <code>@TypeOf</code>, щоб допомогти нам перевірити тип різних змінних. З нашого використання, вам буде пробачено, якщо ви подумаєте, що він повертає назву типу як рядок. Однак, враховуючи, що це функція PascalCase, ви повинні знати краще: вона повертає <code>type</code>.</p><p>Одне з моїх улюблених застосувань <code>anytype</code> — це поєднання його з вбудованими функціями <code>@TypeOf</code> і <code>@hasField</code> для написання помічників тестів. Хоча кожен тип користувача, який ми бачили, був дуже простим, я попрошу вас уявити більш складну структуру з багатьма полями. У багатьох наших тестах нам потрібен <code>User</code>, але ми хочемо вказати лише поля, які стосуються тесту. Давайте створимо <code>userFactory</code>:</p><pre><code class="zig"><span class="keyword function">fn</span> <span class="function">userFactory</span><span class="punctuation bracket">(</span><span class="parameter">data</span><span class="punctuation delimiter">:</span> <span class="type builtin">anytype</span><span class="punctuation bracket">)</span> <span class="variable">User</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">T</span> = <span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">data</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">id</span> = <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="function builtin">@hasField</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation delimiter">,</span> <span class="string">&quot;id&quot;</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="variable">data</span><span class="punctuation delimiter">.</span><span class="field">id</span> <span class="conditional">else</span> <span class="number">0</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="function builtin">@hasField</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation delimiter">,</span> <span class="string">&quot;power&quot;</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="variable">data</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="conditional">else</span> <span class="number">0</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">active</span> = <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="function builtin">@hasField</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation delimiter">,</span> <span class="string">&quot;active&quot;</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="variable">data</span><span class="punctuation delimiter">.</span><span class="field">active</span> <span class="conditional">else</span> <span class="boolean">true</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="function builtin">@hasField</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation delimiter">,</span> <span class="string">&quot;name&quot;</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="variable">data</span><span class="punctuation delimiter">.</span><span class="field">name</span> <span class="conditional">else</span> <span class="string">&quot;&quot;</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">id</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">active</span><span class="punctuation delimiter">:</span> <span class="type builtin">bool</span><span class="punctuation delimiter">,</span>
  <span class="field">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span> <span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Користувача за замовчуванням можна створити, викликавши <code>userFactory({})</code>, або ми можемо перевизначити певні поля за допомогою <code>userFactory(.{.id = 100, .active = false})</code>. Це маленький візерунок, але він мені дуже подобається. Це також гарний дитячий крок у світ метапрограмування.</p><p>Найчастіше <code>@TypeOf</code> поєднується з <code>@typeInfo</code>, який повертає <code>std.builtin.Type</code>. Це потужне об’єднання тегів, яке повністю описує тип. Функція <code>std.json.stringify</code> рекурсивно використовує це в наданому <code>value</code>, щоб визначити, як його серіалізувати.</p><h2>Саситема Зборки Zig</h2><p>Якщо ви прочитали весь цей посібник, чекаючи розуміння того, як створити більш складні проекти з кількома залежностями та різними цілями, ви скоро будете розчаровані. Zig має настільки потужну систему збирання, що все більше проектів, що не належать до Zig, використовують її, наприклад libsodium. На жаль, уся ця потужність означає, що для простіших потреб її не найпростіше використовувати чи розуміти.</p><hr><blockquote><p>Правда в тому, що я недостатньо добре розумію систему збірки Zig, щоб пояснити її.</p></blockquote><hr><p>Тим не менш, ми можемо отримати принаймні короткий огляд. Щоб запустити наш Zig-код, ми використали <code>zig run learning.zig</code>. Одного разу ми також використали <code>zig test learning.zig</code> для запуску тесту. Команди <code>run</code> і <code>test</code> чудово підходять для гри, але це команда <code>build</code>, яка вам знадобиться для чогось більш складного. Команда <code>build</code> покладається на файл <code>build.zig</code> зі спеціальною точкою входу <code>build</code>. Ось скелет:</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">build</span><span class="punctuation bracket">(</span><span class="parameter">b</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">Build</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="variable">_</span> <span class="operator">=</span> <span class="variable">b</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Кожна збірка має типовий крок «встановлення», який тепер можна виконати за допомогою <code>zig build install</code>, але оскільки наш файл здебільшого порожній, ви не отримаєте жодних значущих артефактів. Нам потрібно повідомити нашій збірці про точку входу нашої програми, яка знаходиться в <code>learning.zig</code>:</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">build</span><span class="punctuation bracket">(</span><span class="parameter">b</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">Build</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">target</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">standardTargetOptions</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">optimize</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">standardOptimizeOption</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="comment">// налаштування виконуваного файлу</span>
  <span class="type qualifier">const</span> <span class="variable">exe</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addExecutable</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="string">&quot;learning&quot;</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">target</span> = <span class="variable">target</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">optimize</span> = <span class="variable">optimize</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">root_source_file</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">path</span><span class="punctuation bracket">(</span><span class="string">&quot;learning.zig&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">installArtifact</span><span class="punctuation bracket">(</span><span class="variable">exe</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Тепер, якщо ви запустите <code>zig build install</code>, ви отримаєте двійковий файл у <code>./zig-out/bin/learning</code>. Використання стандартних цілей і оптимізацій дозволяє нам перевизначати значення за замовчуванням як аргументи командного рядка. Наприклад, щоб створити оптимізовану за розміром версію нашої програми для Windows, ми б зробили:</p><pre><code>zig build install -Doptimize=ReleaseSmall -Dtarget=x86_64-windows-gnu
</code></pre><p>Виконуваний файл часто має два додаткові кроки, окрім <code>install</code> за замовчуванням: <code>run</code> та <code>test</code>. Бібліотека може мати один <code>test</code> крок. Для базового <code>run</code> без аргументів нам потрібно додати чотири рядки в кінець нашої збірки:</p><pre><code class="zig"><span class="comment">// додайте після: b.installArtifact(exe);</span>

<span class="type qualifier">const</span> <span class="variable">run_cmd</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addRunArtifact</span><span class="punctuation bracket">(</span><span class="variable">exe</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">run_cmd</span><span class="punctuation delimiter">.</span><span class="field">step</span><span class="punctuation delimiter">.</span><span class="function">dependOn</span><span class="punctuation bracket">(</span><span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">getInstallStep</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="error">;</span>

<span class="type qualifier">const</span> <span class="variable">run_step</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">step</span><span class="punctuation bracket">(</span><span class="string">&quot;run&quot;</span><span class="punctuation delimiter">,</span> <span class="string">&quot;Start learning!&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">run_step</span><span class="punctuation delimiter">.</span><span class="function">dependOn</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">run_cmd</span><span class="punctuation delimiter">.</span><span class="field">step</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>Це створює дві залежності за допомогою двох викликів <code>dependOn</code>. Перший прив’язує нашу нову команду запуску до вбудованого кроку встановлення. Другий пов’язує крок «виконати» з новоствореною командою «виконати». Вам може бути цікаво, навіщо вам потрібна команда запуску, а також крок запуску. Я вважаю, що це розділення існує для підтримки більш складних налаштувань: кроків, які залежать від кількох команд, або команд, які використовуються в кількох кроках. Якщо ви запустите <code>zig build --help</code> і прокрутите догори, ви побачите наш новий крок "виконати". Тепер ви можете запустити програму, виконавши <code>zig build run</code>.</p><p>Щоб додати «тестовий» крок, ви скопіюєте більшу частину коду запуску, який ми щойно додали, але замість <code>b.addExecutable</code>, ви почнете роботу з <code>b.addTest</code>:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">tests</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addTest</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
  <span class="punctuation delimiter">.</span><span class="field">target</span> = <span class="variable">target</span><span class="punctuation delimiter">,</span>
  <span class="punctuation delimiter">.</span><span class="field">optimize</span> = <span class="variable">optimize</span><span class="punctuation delimiter">,</span>
  <span class="punctuation delimiter">.</span><span class="field">root_source_file</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">path</span><span class="punctuation bracket">(</span><span class="string">&quot;learning.zig&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="type qualifier">const</span> <span class="variable">test_cmd</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addRunArtifact</span><span class="punctuation bracket">(</span><span class="variable">tests</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">test_cmd</span><span class="punctuation delimiter">.</span><span class="field">step</span><span class="punctuation delimiter">.</span><span class="function">dependOn</span><span class="punctuation bracket">(</span><span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">getInstallStep</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="error">;</span>
<span class="type qualifier">const</span> <span class="variable">test_step</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">step</span><span class="punctuation bracket">(</span><span class="string">&quot;test&quot;</span><span class="punctuation delimiter">,</span> <span class="string">&quot;Run the tests&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">test_step</span><span class="punctuation delimiter">.</span><span class="function">dependOn</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">test_cmd</span><span class="punctuation delimiter">.</span><span class="field">step</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>Ми дали цьому кроку назву «тест». Запуск <code>zig build --help</code> має показати ще один доступний крок, "test". Оскільки у нас немає тестів, важко сказати, працює це чи ні. У <code>learning.zig</code> додайте:</p><pre><code class="zig"><span class="keyword">test</span> <span class="string">&quot;dummy build test&quot;</span> <span class="punctuation bracket">{</span>
  <span class="operator">try</span> <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">testing</span><span class="punctuation delimiter">.</span><span class="function">expectEqual</span><span class="punctuation bracket">(</span><span class="boolean">false</span><span class="punctuation delimiter">,</span> <span class="boolean">true</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Тепер, коли ви запускаєте <code>zig build test</code>, ви повинні отримати помилку тесту. Якщо ви виправите тест і знову запустите <code>zig build test</code>, ви не отримаєте результату. За замовчуванням тестовий бігун Zig виводить лише у разі помилки. Використовуйте <code>zig build test --summary all</code>, якщо, як і я, вам завжди потрібен підсумок, незалежно від того, пройдено чи не пройдено.</p><p>Це мінімальна конфігурація, яка вам знадобиться для початку роботи. Але будьте спокійні, знаючи, що якщо вам потрібно його створити, Зіг, ймовірно, впорається з цим. Нарешті, ви можете і, мабуть, повинні використовувати <code>zig init</code> у корені вашого проекту, щоб Zig створив для вас добре задокументований файл <code>build.zig</code>.</p><h2>Сторонні Залежності</h2><p>Вбудований менеджер пакетів Zig відносно новий і, як наслідок, має ряд недоліків. Хоча є місце для вдосконалення, його можна використовувати як є. Нам потрібно розглянути дві частини: створення пакета та використання пакетів. Ми пройдемося по цьому повністю.</p><p>Спочатку створіть нову папку під назвою <code>calc</code> і створіть три файли. Перший – це <code>add.zig</code> з таким вмістом:</p><pre><code class="zig"><span class="comment">// Ой, прихований урок, подивіться на вид б</span>
<span class="comment">// і тип повернення!!</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">add</span><span class="punctuation bracket">(</span><span class="parameter">a</span><span class="punctuation delimiter">:</span> <span class="type builtin">anytype</span><span class="punctuation delimiter">,</span> <span class="parameter">b</span><span class="punctuation delimiter">:</span> <span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">a</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">a</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
  <span class="keyword return">return</span> <span class="variable">a</span> <span class="operator">+</span> <span class="variable">b</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="type qualifier">const</span> <span class="variable">testing</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="field">testing</span><span class="punctuation delimiter">;</span>

<span class="keyword">test</span> <span class="string">&quot;add&quot;</span> <span class="punctuation bracket">{</span>
  <span class="operator">try</span> <span class="variable">testing</span><span class="punctuation delimiter">.</span><span class="function">expectEqual</span><span class="punctuation bracket">(</span><span class="function builtin">@as</span><span class="punctuation bracket">(</span><span class="type builtin">i32</span><span class="punctuation delimiter">,</span> <span class="number">32</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable">add</span><span class="punctuation bracket">(</span><span class="number">30</span><span class="punctuation delimiter">,</span> <span class="number">2</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Це трохи безглуздо, цілий пакет просто додати два значення, але це дозволить нам зосередитися на аспекті упаковки. Далі ми додамо не менш дурний: <code>calc.zig</code>:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">add</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;add.zig&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="field">add</span><span class="punctuation delimiter">;</span>

<span class="keyword">test</span> <span class="punctuation bracket">{</span>
  <span class="comment">// За замовчуванням лише тести у вказаному файлі</span>
  <span class="comment">// включені. Цей чарівний рядок коду буде</span>
  <span class="comment">// викликати посилання на всі вкладені контейнери</span>
  <span class="comment">// для перевірки.</span>
  <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="field">testing</span><span class="punctuation delimiter">.</span><span class="function">refAllDecls</span><span class="punctuation bracket">(</span><span class="function builtin">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Ми розділяємо це між <code>calc.zig</code> і <code>add.zig</code>, щоб довести, що <code>zig build</code> автоматично створить і запакує всі файли нашого проекту. Нарешті, ми можемо додати <code>build.zig</code>:</p><p><em>learning.zig</em></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">build</span><span class="punctuation bracket">(</span><span class="parameter">b</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">Build</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">target</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">standardTargetOptions</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">optimize</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">standardOptimizeOption</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">const</span> <span class="variable">tests</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addTest</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">target</span> = <span class="variable">target</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">optimize</span> = <span class="variable">optimize</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">root_source_file</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">path</span><span class="punctuation bracket">(</span><span class="string">&quot;calc.zig&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">const</span> <span class="variable">test_cmd</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addRunArtifact</span><span class="punctuation bracket">(</span><span class="variable">tests</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">test_cmd</span><span class="punctuation delimiter">.</span><span class="field">step</span><span class="punctuation delimiter">.</span><span class="function">dependOn</span><span class="punctuation bracket">(</span><span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">getInstallStep</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">test_step</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">step</span><span class="punctuation bracket">(</span><span class="string">&quot;test&quot;</span><span class="punctuation delimiter">,</span> <span class="string">&quot;Run the tests&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">test_step</span><span class="punctuation delimiter">.</span><span class="function">dependOn</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">test_cmd</span><span class="punctuation delimiter">.</span><span class="field">step</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Це все повторення того, що ми бачили в попередньому розділі. З цим ви можете запустити <code>zig build test --summary all</code>.</p><p>Повернемося до нашого навчального проекту та раніше створеного <code>build.zig</code>. Ми почнемо з додавання нашого локального <code>calc</code> як залежності. Нам потрібно зробити три доповнення. Спочатку ми створимо модуль, який вказує на наш <code>calc.zig</code>:</p><pre><code class="zig"><span class="comment">// Ви можете розмістити це у верхній частині збірки</span>
<span class="comment">// функція перед викликом add Executable.</span>

<span class="type qualifier">const</span> <span class="variable">calc_module</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addModule</span><span class="punctuation bracket">(</span><span class="string">&quot;calc&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
  <span class="punctuation delimiter">.</span><span class="field">root_source_file</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">path</span><span class="punctuation bracket">(</span><span class="string">&quot;PATH_TO_CALC_PROJECT/calc.zig&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Вам потрібно буде змінити шлях до <code>calc.zig</code>. Тепер нам потрібно додати цей модуль до наших існуючих змінних <code>exe</code> і <code>tests</code>. Оскільки наш <code>build.zig</code> стає більш зайнятим, ми спробуємо трохи впорядкувати речі:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">build</span><span class="punctuation bracket">(</span><span class="parameter">b</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">Build</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">target</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">standardTargetOptions</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">optimize</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">standardOptimizeOption</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">const</span> <span class="variable">calc_module</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addModule</span><span class="punctuation bracket">(</span><span class="string">&quot;calc&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">root_source_file</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">path</span><span class="punctuation bracket">(</span><span class="string">&quot;PATH_TO_CALC_PROJECT/calc.zig&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="punctuation bracket">{</span>
    <span class="comment">// налаштовуємо &quot;run&quot; команду</span>
    <span class="type qualifier">const</span> <span class="variable">exe</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addExecutable</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
      <span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="string">&quot;learning&quot;</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">target</span> = <span class="variable">target</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">optimize</span> = <span class="variable">optimize</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">root_source_file</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">path</span><span class="punctuation bracket">(</span><span class="string">&quot;learning.zig&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="comment">// додайте це</span>
    <span class="variable">exe</span><span class="punctuation delimiter">.</span><span class="field">root_module</span><span class="punctuation delimiter">.</span><span class="function">addImport</span><span class="punctuation bracket">(</span><span class="string">&quot;calc&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">calc_module</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">installArtifact</span><span class="punctuation bracket">(</span><span class="variable">exe</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="type qualifier">const</span> <span class="variable">run_cmd</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addRunArtifact</span><span class="punctuation bracket">(</span><span class="variable">exe</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="variable">run_cmd</span><span class="punctuation delimiter">.</span><span class="field">step</span><span class="punctuation delimiter">.</span><span class="function">dependOn</span><span class="punctuation bracket">(</span><span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">getInstallStep</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="type qualifier">const</span> <span class="variable">run_step</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">step</span><span class="punctuation bracket">(</span><span class="string">&quot;run&quot;</span><span class="punctuation delimiter">,</span> <span class="string">&quot;Start learning!&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="variable">run_step</span><span class="punctuation delimiter">.</span><span class="function">dependOn</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">run_cmd</span><span class="punctuation delimiter">.</span><span class="field">step</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>

  <span class="punctuation bracket">{</span>
    <span class="comment">// налаштовуємо &quot;test&quot; команду</span>
    <span class="type qualifier">const</span> <span class="variable">tests</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addTest</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
      <span class="punctuation delimiter">.</span><span class="field">target</span> = <span class="variable">target</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">optimize</span> = <span class="variable">optimize</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">root_source_file</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">path</span><span class="punctuation bracket">(</span><span class="string">&quot;learning.zig&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="comment">// додайте це</span>
    <span class="variable">tests</span><span class="punctuation delimiter">.</span><span class="field">root_module</span><span class="punctuation delimiter">.</span><span class="function">addImport</span><span class="punctuation bracket">(</span><span class="string">&quot;calc&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">calc_module</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="type qualifier">const</span> <span class="variable">test_cmd</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addRunArtifact</span><span class="punctuation bracket">(</span><span class="variable">tests</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="variable">test_cmd</span><span class="punctuation delimiter">.</span><span class="field">step</span><span class="punctuation delimiter">.</span><span class="function">dependOn</span><span class="punctuation bracket">(</span><span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">getInstallStep</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="type qualifier">const</span> <span class="variable">test_step</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">step</span><span class="punctuation bracket">(</span><span class="string">&quot;test&quot;</span><span class="punctuation delimiter">,</span> <span class="string">&quot;Run the tests&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="variable">test_step</span><span class="punctuation delimiter">.</span><span class="function">dependOn</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">test_cmd</span><span class="punctuation delimiter">.</span><span class="field">step</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>

<span class="punctuation bracket">}</span>
</code></pre>
<p>Зі свого проекту тепер ви можете <code>@import(&quot;calc&quot;)</code>:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">calc</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;calc&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="error">...
calc</span><span class="punctuation delimiter">.</span><span class="variable builtin">add</span><span class="punctuation bracket">(</span><span class="number">1</span><span class="punctuation delimiter">,</span> <span class="number">2</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>Додавання віддаленої залежності вимагає трохи більше зусиль. По-перше, нам потрібно повернутися до проекту <code>calc</code> і визначити модуль. Ви можете подумати, що проект сам по собі є модулем, але проект може виставляти кілька модулів, тому нам потрібно явно створити його. Ми використовуємо той самий <code>addModule</code>, але відкидаємо повернуте значення. Простого виклику <code>addModule</code> достатньо, щоб визначити модуль, який потім зможуть імпортувати інші проекти.</p><pre><code class="zig"><span class="variable">_</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addModule</span><span class="punctuation bracket">(</span><span class="string">&quot;calc&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
  <span class="punctuation delimiter">.</span><span class="field">root_source_file</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">path</span><span class="punctuation bracket">(</span><span class="string">&quot;calc.zig&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>Це єдина зміна, яку нам потрібно внести в нашу бібліотеку. Оскільки це вправа мати віддалену залежність, я передав цей проект <code>calc</code> на Github, щоб ми могли імпортувати його в наш навчальний проект. Він доступний на <a href="https://github.com/karlseguin/calc.zig" target="_blank">https://github.com/karlseguin/calc.zig</a>.</p><p>У нашому навчальному проекті нам потрібен новий файл, <code>build.zig.zon</code>. «ZON» розшифровується як нотація об’єктів Zig і дозволяє виражати дані Zig у форматі, зрозумілому людині, і перетворювати цей формат на Zig-код. Вміст <code>build.zig.zon</code> буде таким:</p><pre><code class="zig"><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
  <span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="string">&quot;learning&quot;</span><span class="punctuation delimiter">,</span>
  <span class="punctuation delimiter">.</span><span class="field">paths</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="string">&quot;&quot;</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
  <span class="punctuation delimiter">.</span><span class="field">version</span> = <span class="string">&quot;0.0.0&quot;</span><span class="punctuation delimiter">,</span>
  <span class="punctuation delimiter">.</span><span class="field">dependencies</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">calc</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
      <span class="punctuation delimiter">.</span><span class="field">url</span> = <span class="string">&quot;https://github.com/karlseguin/calc.zig/archive/d1881b689817264a5644b4d6928c73df8cf2b193.tar.gz&quot;</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">hash</span> = <span class="string">&quot;12ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&quot;</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>У цьому файлі є два сумнівних значення, перше – <code>d1881b689817264a5644b4d6928c73df8cf2b193</code> в <code>url</code>. Це просто хеш git commit. Друге - це значення "хеш". Наскільки я знаю, наразі немає чудового способу визначити, яким має бути це значення, тому поки що ми використовуємо фіктивне значення.</p><p>Щоб використовувати цю залежність, нам потрібно внести одну зміну до нашого <code>build.zig</code>:</p><pre><code class="zig"><span class="comment">// замініть це:</span>
<span class="type qualifier">const</span> <span class="variable">calc_module</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">addModule</span><span class="punctuation bracket">(</span><span class="string">&quot;calc&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
  <span class="punctuation delimiter">.</span><span class="field">root_source_file</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">path</span><span class="punctuation bracket">(</span><span class="string">&quot;calc/calc.zig&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="comment">// цим:</span>
<span class="type qualifier">const</span> <span class="variable">calc_dep</span> = <span class="variable">b</span><span class="punctuation delimiter">.</span><span class="function">dependency</span><span class="punctuation bracket">(</span><span class="string">&quot;calc&quot;</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">target</span> = <span class="variable">target</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="field">optimize</span> = <span class="variable">optimize</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">calc_module</span> = <span class="variable">calc_dep</span><span class="punctuation delimiter">.</span><span class="function">module</span><span class="punctuation bracket">(</span><span class="string">&quot;calc&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>У <code>build.zig.zon</code> ми назвали залежність <code>calc</code>, і це залежність, яку ми тут завантажуємо. З цієї залежності ми беремо модуль <code>calc</code>, який ми назвали модуль у <code>build.zig</code> <code>calc</code>.</p><p>Якщо ви спробуєте запустити <code>zig build test</code>, ви повинні побачити помилку:</p><pre><code>hash mismatch: manifest declares
122053da05e0c9348d91218ef015c8307749ef39f8e90c208a186e5f444e818672da

but the fetched package has
122036b1948caa15c2c9054286b3057877f7b152a5102c9262511bf89554dc836ee5
</code></pre><p>Скопіюйте та вставте правильний хеш назад у <code>build.zig.zon</code> і спробуйте знову запустити <code>zig build test</code>. Тепер все повинно працювати.</p><p>Звучить як багато, і я сподіваюся, що все впорядкується. Але здебільшого це те, що можна скопіювати та вставити з інших проектів, а після налаштування можна рухатися далі.</p><p>Коротке попередження: я виявив, що кешування залежностей Zig є агресивним. Якщо ви намагаєтеся оновити залежність, але Zig, здається, не виявляє зміни... добре, я видаляю папку <code>zig-cache</code> проекту, а також <code>~/.cache/zig</code>.</p><hr><p>Ми охопили багато інформації, дослідивши кілька основних структур даних і об’єднавши великі фрагменти попередніх частин. Наш код став трохи складнішим, менше зосереджуючись на певному синтаксисі та більше схожим на справжній код. Я в захваті від можливості того, що, незважаючи на таку складність, код переважно мав сенс. Якщо ні, не здавайтеся. Виберіть приклад і розбийте його, додайте оператори друку, напишіть кілька тестів для нього. Опрацюйте код, створіть свій власний, а потім поверніться та прочитайте ті частини, які не мали сенсу.</p></div>
	
        </div>
      </div>
    </div>
  </body>
</html>