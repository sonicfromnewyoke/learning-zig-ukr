<!DOCTYPE html>
<html>

<head id="head">
  <meta charset="UTF-8">
  <meta name="description" content="Вивчаємо Zig Українською">
  <meta property="og:title" content="Узагальнені структури даних">
  <meta property="og:type" content="website">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title id="title">
    Узагальнені структури даних
      Вивчаємо Zig Українською
  </title>
  <link rel="stylesheet" type="text/css" href="/learning-zig-ukr/style.css">
  <link rel="stylesheet" type="text/css" href="/learning-zig-ukr/highlight.css">
  
</head>

<body>
  <header>
    <h1>Вивчаємо Zig Українською</h1>
  </header>
  <div id="main-wrapper">
    <div id="navigation">
      <nav aria-labelledby="table-of-contents">
        <h2 id="table-of-contents">Зміст</h2>
        <ul>
          <li><a id="toc-Index" href="/learning-zig-ukr/">Вступ</a></li>
          <li><a id="toc-Language-Overview-1" href="/learning-zig-ukr/language-overview-1">Огляд Мови, частина 1</a></li>
          <li><a id="toc-Language-Overview-2" href="/learning-zig-ukr/language-overview-2">Огляд Мови, частина 2</a></li>
          <li><a id="toc-Style-Guide" href="/learning-zig-ukr/style-guide">Керівництво по стилю оформлення</a></li>
          <li><a id="toc-Pointers" href="/learning-zig-ukr/pointers">Вказівники</a></li>
          <li><a id="toc-Stack-Memory" href="/learning-zig-ukr/stack-memory">Стекова пам'ять</a></li>
          <li><a id="toc-Heap-Memory" href="/learning-zig-ukr/heap-memory">Динамічна пам'ять та розподільники пам'яті</a></li>
          <li><a id="toc-Generics" href="/learning-zig-ukr/generics">Узагальнені структури даних</a></li>
          <li><a id="toc-Coding-In-Zig" href="/learning-zig-ukr/coding-in-zig">Програмуємо мовою Zig</a></li>
          <li><a id="toc-Conclusion" href="/learning-zig-ukr/conclusion">Висоновки</a></li>
        </ul>
      </nav>
    </div>
    <div id="contents-wrapper">
      <div id="content">
        
		<h1 >Узагальнені структури даних</h1>
		<div id="docs" ><p>У попередній частині ми створили простий динамічний масив під назвою <code>IntList</code>. Метою структури даних було зберігати динамічну кількість значень. Хоча використаний нами алгоритм працював би для будь-якого типу даних, наша реалізація була прив’язана до значень <code>i64</code>. Введіть генерики, метою яких є абстрагування алгоритмів і структур даних від конкретних типів.</p><p>Багато мов реалізують універсали зі спеціальним синтаксисом і специфічними для узагальнених правил. У Zig генерики є не такою специфічною особливістю, як вираженням того, на що здатна мова. Зокрема, дженерики використовують потужне метапрограмування Zig під час компіляції.</p><p>Ми почнемо з розгляду дурного прикладу, щоб зорієнтуватися:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">arr</span><span class="punctuation delimiter">:</span> <span class="variable">IntArray</span><span class="punctuation bracket">(</span><span class="number">3</span><span class="punctuation bracket">)</span> = <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
  <span class="variable">arr</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
  <span class="variable">arr</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="number">10</span><span class="punctuation delimiter">;</span>
  <span class="variable">arr</span><span class="punctuation bracket">[</span><span class="number">2</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{any}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">arr</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword function">fn</span> <span class="function">IntArray</span><span class="punctuation bracket">(</span><span class="attribute">comptime</span> <span class="parameter">length</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
  <span class="keyword return">return</span> <span class="punctuation bracket">[</span><span class="variable builtin">length</span><span class="punctuation bracket">]</span><span class="type builtin">i64</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
</figure>
<p>Наведене вище друкує <code>{ 1, 10, 100 }</code>. Цікава частина полягає в тому, що у нас є функція, яка повертає <code>тип</code> (отже, функція PascalCase). Не будь-який тип, а тип, заснований на параметрі функції. Цей код працював лише тому, що ми оголосили <code>length</code> як <code>comptime</code>. Тобто ми вимагаємо від усіх, хто викликає <code>IntArray</code>, передавати відомий під час компіляції параметр <code>length</code>. Це необхідно, оскільки наша функція повертає <code>type</code>, а <code>types</code> завжди мають бути відомі під час компіляції.</p><p>Функція може повертати <i>будь-який</i> тип, а не лише примітиви та масиви. Наприклад, з невеликою зміною ми можемо повернути структуру:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">arr</span><span class="punctuation delimiter">:</span> <span class="variable">IntArray</span><span class="punctuation bracket">(</span><span class="number">3</span><span class="punctuation bracket">)</span> = <span class="constant builtin">undefined</span><span class="punctuation delimiter">;</span>
  <span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
  <span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="number">10</span><span class="punctuation delimiter">;</span>
  <span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">2</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{any}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword function">fn</span> <span class="function">IntArray</span><span class="punctuation bracket">(</span><span class="attribute">comptime</span> <span class="parameter">length</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
  <span class="keyword return">return</span> <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
    <span class="field">items</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="variable builtin">length</span><span class="punctuation bracket">]</span><span class="type builtin">i64</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
</figure>
<p>Це може здатися дивним, але тип <code>arr</code> насправді є <code>IntArray(3)</code>. Це такий же тип, як і будь-який інший тип, а <code>arr</code> — це значення, як і будь-яке інше значення. Якби ми викликали <code>IntArray(7)</code>, це був би інший тип. Можливо, ми зможемо зробити речі акуратнішими:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">arr</span> = <span class="variable">IntArray</span><span class="punctuation bracket">(</span><span class="number">3</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
  <span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="number">10</span><span class="punctuation delimiter">;</span>
  <span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">2</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="number">100</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{any}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">arr</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword function">fn</span> <span class="function">IntArray</span><span class="punctuation bracket">(</span><span class="attribute">comptime</span> <span class="parameter">length</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
  <span class="keyword return">return</span> <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
    <span class="field">items</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="variable builtin">length</span><span class="punctuation bracket">]</span><span class="type builtin">i64</span><span class="punctuation delimiter">,</span>

    <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="variable">IntArray</span><span class="punctuation bracket">(</span><span class="variable">length</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
      <span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
        <span class="punctuation delimiter">.</span><span class="field">items</span> = <span class="constant builtin">undefined</span><span class="punctuation delimiter">,</span>
      <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
</figure>
<p>На перший погляд це може виглядати не акуратніше. Але крім того, що наша структура безіменна та вкладена у функцію, вона виглядає як будь-яка інша структура, яку ми бачили досі. У нього є поля, у нього є функції. Ви знаєте, як кажуть, <i>якщо це схоже на качку...</i>. Ну, це виглядає, плаває і крякає як звичайна структура, тому що це так.</p><p>Ми вибрали цей шлях, щоб звикнути до функції, яка повертає тип і відповідний синтаксис. Щоб отримати типовіший дженерик, нам потрібно зробити останню зміну: наша функція має прийняти <code>type</code>. Насправді це невелика зміна, але «тип» може здаватися більш абстрактним, ніж «використання», тому ми робили це повільно. Давайте зробимо стрибок і змінимо наш попередній <code>IntList</code> для роботи з будь-яким типом. Почнемо зі скелета:</p><pre><code class="zig"><span class="keyword function">fn</span> <span class="function">List</span><span class="punctuation bracket">(</span><span class="attribute">comptime</span> <span class="parameter">T</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
  <span class="keyword return">return</span> <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
    <span class="field">pos</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span><span class="punctuation delimiter">,</span>
    <span class="field">items</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="variable">T</span><span class="punctuation delimiter">,</span>
    <span class="field">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation delimiter">,</span>

    <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="parameter">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="variable">List</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
      <span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
        <span class="punctuation delimiter">.</span><span class="field">pos</span> = <span class="number">0</span><span class="punctuation delimiter">,</span>
        <span class="punctuation delimiter">.</span><span class="field">allocator</span> = <span class="variable">allocator</span><span class="punctuation delimiter">,</span>
        <span class="punctuation delimiter">.</span><span class="field">items</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
      <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Наведена вище <code>struct</code> майже ідентична нашому <code>IntList</code>, за винятком <code>i64</code>, заміненого на <code>T</code>. Це <code>T</code> може здатися особливим, але це лише назва змінної. Ми могли б назвати це <code>item_type</code>. Однак, дотримуючись угоди про іменування Zig, змінні типу <code>type</code> є PascalCase.</p><hr><blockquote><p>Добре це чи погано, використання однієї літери для представлення параметра типу набагато старше, ніж Zig. <code>T</code> є звичайним за замовчуванням у більшості мов, але ви побачите залежні від контексту варіації, такі як хеш-карти з використанням <code>K</code> і <code>V</code> для типів параметрів ключа та значення.</p></blockquote><hr><p>Якщо ви не впевнені щодо нашого скелета, розгляньте два місця, де ми використовуємо <code>T</code>: <code>items: []T</code> і <code>allocator.alloc(T, 4)</code>. Якщо ми хочемо використовувати цей загальний тип, ми створимо екземпляр за допомогою:</p><pre><code class="zig"><span class="type qualifier">var</span> <span class="variable">list</span> = <span class="operator">try</span> <span class="variable">List</span><span class="punctuation bracket">(</span><span class="type builtin">u32</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Коли код компілюється, компілятор створює новий тип, знаходячи кожен <code>T</code> і замінюючи його на <code>u32</code>. Якщо ми знову використаємо <code>List(u32)</code>, компілятор повторно використає тип, який він створив раніше. Якщо ми вкажемо нове значення для "T", наприклад "List(bool)" або "List(User)", буде створено нові типи.</p><p>Щоб завершити наш загальний <code>List</code>, ми можемо буквально скопіювати та вставити решту коду <code>IntList</code> і замінити <code>i64</code> на <code>T</code>. Ось повний робочий приклад:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">Allocator</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="field">Allocator</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="type qualifier">var</span> <span class="variable">list</span> = <span class="operator">try</span> <span class="variable">List</span><span class="punctuation bracket">(</span><span class="type builtin">u32</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="keyword">defer</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

  <span class="repeat">for</span> <span class="punctuation bracket">(</span><span class="number">0</span><span class="punctuation special">..</span><span class="number">10</span><span class="punctuation bracket">)</span> |<span class="variable">i</span>| <span class="punctuation bracket">{</span>
    <span class="operator">try</span> <span class="variable">list</span><span class="punctuation delimiter">.</span><span class="function">add</span><span class="punctuation bracket">(</span><span class="function builtin">@intCast</span><span class="punctuation bracket">(</span><span class="variable">i</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>

  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{any}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">list</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation special">..</span><span class="variable">list</span><span class="punctuation delimiter">.</span><span class="field">pos</span><span class="punctuation bracket">]</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword function">fn</span> <span class="function">List</span><span class="punctuation bracket">(</span><span class="attribute">comptime</span> <span class="parameter">T</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
  <span class="keyword return">return</span> <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
    <span class="field">pos</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span><span class="punctuation delimiter">,</span>
    <span class="field">items</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="variable">T</span><span class="punctuation delimiter">,</span>
    <span class="field">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation delimiter">,</span>

    <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="parameter">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="variable">List</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
      <span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
        <span class="punctuation delimiter">.</span><span class="field">pos</span> = <span class="number">0</span><span class="punctuation delimiter">,</span>
        <span class="punctuation delimiter">.</span><span class="field">allocator</span> = <span class="variable">allocator</span><span class="punctuation delimiter">,</span>
        <span class="punctuation delimiter">.</span><span class="field">items</span> = <span class="operator">try</span> <span class="variable">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span>
      <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>

    <span class="keyword function">fn</span> <span class="function">deinit</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="variable">List</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
      <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>

    <span class="keyword function">fn</span> <span class="function">add</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">List</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="parameter">value</span><span class="punctuation delimiter">:</span> <span class="variable">T</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
      <span class="type qualifier">const</span> <span class="variable">pos</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">pos</span><span class="punctuation delimiter">;</span>
      <span class="type qualifier">const</span> <span class="variable">len</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation delimiter">.</span><span class="field">len</span><span class="punctuation delimiter">;</span>

      <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">pos</span> <span class="operator">==</span> <span class="variable">len</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
        <span class="comment">// у нас закінчилось місце</span>
        <span class="comment">// створюємо новий, вдвічі більший зріз</span>
        <span class="type qualifier">var</span> <span class="variable">larger</span> = <span class="operator">try</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">allocator</span><span class="punctuation delimiter">.</span><span class="function">alloc</span><span class="punctuation bracket">(</span><span class="variable">T</span><span class="punctuation delimiter">,</span> <span class="variable">len</span> <span class="operator">*</span> <span class="number">2</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

        <span class="comment">// копіюємо в нього всі елементи з попереднього</span>
        <span class="function builtin">@memcpy</span><span class="punctuation bracket">(</span><span class="variable">larger</span><span class="punctuation bracket">[</span><span class="number">0</span><span class="punctuation special">..</span><span class="variable">len</span><span class="punctuation bracket">]</span><span class="punctuation delimiter">,</span> <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

        <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">allocator</span><span class="punctuation delimiter">.</span><span class="function">free</span><span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

        <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span> <span class="operator">=</span> <span class="variable">larger</span><span class="punctuation delimiter">;</span>
      <span class="punctuation bracket">}</span>

      <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">items</span><span class="punctuation bracket">[</span><span class="variable">pos</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="variable">value</span><span class="punctuation delimiter">;</span>
      <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">pos</span> <span class="operator">=</span> <span class="variable">pos</span> <span class="operator">+</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
</figure>
<p>Наша функція <code>init</code> повертає <code>List(T)</code>, а наші функції <code>deinit</code> і <code>add</code> приймають <code>List(T)</code> і <code>*List(T)</code>. У нашому простому класі це добре, але для великих структур даних написання повної загальної назви може стати трохи виснажливим, особливо якщо у нас є кілька параметрів типу (наприклад, хеш-карта, яка приймає окремий «тип» для свого ключа та значення) . Вбудована функція <code>@This()</code> повертає внутрішній <code>type</code>, звідки вона викликана. Швидше за все, наш <code>List(T)</code> буде записаний так:</p><pre><code class="zig"><span class="keyword function">fn</span> <span class="function">List</span><span class="punctuation bracket">(</span><span class="attribute">comptime</span> <span class="parameter">T</span><span class="punctuation delimiter">:</span> <span class="type builtin">type</span><span class="punctuation bracket">)</span> <span class="type builtin">type</span> <span class="punctuation bracket">{</span>
  <span class="keyword return">return</span> <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
    <span class="field">pos</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span><span class="punctuation delimiter">,</span>
    <span class="field">items</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="variable">T</span><span class="punctuation delimiter">,</span>
    <span class="field">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation delimiter">,</span>

    <span class="comment">// додано</span>
    <span class="type qualifier">const</span> <span class="variable">Self</span> = <span class="function builtin">@This</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="parameter">allocator</span><span class="punctuation delimiter">:</span> <span class="variable">Allocator</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="variable">Self</span> <span class="punctuation bracket">{</span>
      <span class="comment">// ... той самий код</span>
    <span class="punctuation bracket">}</span>

    <span class="keyword function">fn</span> <span class="function">deinit</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="variable">Self</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
      <span class="comment">// .. той самий код</span>
    <span class="punctuation bracket">}</span>

    <span class="keyword function">fn</span> <span class="function">add</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="operator">*</span><span class="variable">Self</span><span class="punctuation delimiter">,</span> <span class="parameter">value</span><span class="punctuation delimiter">:</span> <span class="variable">T</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
      <span class="comment">// .. той самий код</span>
    <span class="punctuation bracket">}</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p><code>Self</code> — це не спеціальне ім’я, це просто змінна, і це PascalCase, тому що її значення є <code>type</code>. Ми можемо використовувати <code>Self</code> там, де раніше використовували <code>List(T)</code>.</p><hr><p>Ми могли б створити складніші приклади з декількома параметрами типу та досконалішими алгоритмами. Але, зрештою, основний загальний код нічим не відрізнятиметься від простих прикладів вище. У наступній частині ми знову торкнемося генериків, коли поглянемо на <code>ArrayList(T)</code> і <code>StringHashMap(V)</code> стандартної бібліотеки.</p></div>
	
      </div>
    </div>
  </div>
</body>

</html>