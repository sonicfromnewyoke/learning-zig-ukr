<!DOCTYPE html>
<html>

<head id="head">
  <meta charset="UTF-8">
  <meta name="description" content="Вивчаємо Zig Українською">
  <meta property="og:title" content="Огляд Мови, частина 1">
  <meta property="og:type" content="website">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title id="title">
    Огляд Мови, частина 1
      Вивчаємо Zig Українською
  </title>
  <link rel="stylesheet" type="text/css" href="/style.css">
  <link rel="stylesheet" type="text/css" href="/highlight.css">
  
</head>

<body>
  <header>
    <h1>Вивчаємо Zig Українською</h1>
  </header>
  <div id="main-wrapper">
    <div id="navigation">
      <nav aria-labelledby="table-of-contents">
        <h2 id="table-of-contents">Зміст</h2>
        <ul>
          <li><a id="toc-Index" href="/">Вступ</a></li>
          <li><a id="toc-Language-Overview-1" href="/language-overview-1">Огляд Мови, частина 1</a></li>
          <li><a id="toc-Language-Overview-2" href="/language-overview-2">Огляд Мови, частина 2</a></li>
          <li><a id="toc-Style-Guide" href="/style-guide">Керівництво по стилю оформлення</a></li>
          <li><a id="toc-Pointers" href="/pointers">Вказівники</a></li>
          <li><a id="toc-Stack-Memory" href="/stack-memory">Стекова пам'ять</a></li>
          <li><a id="toc-Heap-Memory" href="/heap-memory">Динамічна пам'ять та розподільники пам'яті</a></li>
          <li><a id="toc-Generics" href="/generics">Узагальнені структури даних</a></li>
          <li><a id="toc-Coding-In-Zig" href="/coding-in-zig">Програмуємо мовою Zig</a></li>
          <li><a id="toc-Conclusion" href="/conclusion">Висоновки</a></li>
        </ul>
      </nav>
    </div>
    <div id="contents-wrapper">
      <div id="content">
        
		<h1 >Огляд Мови, частина 1</h1>
		<div id="docs" ><p>Zig — це строго типізована компільована мова. Він підтримує узагальнені типи, має потужні можливості метапрограмування під час компіляції та <strong>не</strong> містить збирач сміття. Багато людей вважають Zig сучасною альтернативою C. Так як, синтаксис мови схожий на C. Ми говоримо про оператори, що завершуються крапкою з комою, і блоки, розділені фігурними дужками</p><p>Ось як виглядає код написаний на Zig:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="comment">// Цей код не буде скомпільовано, якщо `main` не `pub` (публічний)</span>
<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">user</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">9001</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="string">"Goku"</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{s} має силу {d}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">name</span><span class="punctuation delimiter">,</span> <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
</figure>
<p>Якщо ви збережете наведене вище як <i>learning.zig</i> і запустите <code>zig run learning.zig</code>, ви побачите: <code>Потужність Goku становить 9001</code>.</p><p>Це простий приклад, який ви можете зрозуміти, навіть якщо ви вперше бачите Zig. Тим не менш, ми збираємося розглянути це рядок за рядком.</p><hr><blockquote><p>Перегляньте розділ <a href="/#install"">встановлюємо zig</a>, щоб швидко розпочати роботу.</p></blockquote><hr><h2>Імпорт</h2><p>Дуже мало програм написані як один файл без стандартної бібліотеки або зовнішніх бібліотек. Наша перша програма не є винятком і використовує стандартну бібліотеку Zig для друку результату. Система імпорту Zig є простою та покладається на функцію <code>@import</code> і ключове слово <code>pub</code> (щоб зробити код доступним поза поточним файлом).</p><hr><blockquote><p>Функції, які починаються з <code>@</code>, є вбудованими функціями. Вони надаються компілятором на відміну від стандартної бібліотеки.</p></blockquote><hr><p>Ми імпортуємо модуль, вказавши назву модуля. Стандартна бібліотека Zig доступна під назвою «std». Щоб імпортувати певний файл, ми використовуємо його шлях відносно файлу, який виконує імпорт. Наприклад, якщо ми перемістили структуру <code>User</code> у власний файл, скажімо <i>models/user.zig</i>:</p><figure>
<figcaption class="zig-cap">models/user.zig</figcaption>
<pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
</figure>
<p>Потім ми імпортуємо його через:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">User</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"models/user.zig"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">.</span><span class="field">User</span><span class="punctuation delimiter">;</span>
</code></pre>
</figure>
<hr><blockquote><p>Якщо наша структура <code>User</code> не була позначена як <code>pub</code>, ми отримали б таку помилку: <i>'User' is not marked 'pub'</i>.</p></blockquote><hr><p><i>models/user.zig</i> може експортувати більше одного елемента. Наприклад, ми також можемо експортувати константу:</p><figure>
<figcaption class="zig-cap">models/user.zig</figcaption>
<pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">MAX_POWER</span> = <span class="number">100_000</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
</figure>
<p>У цьому випадку ми могли б імпортувати обидва:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">user</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"models/user.zig"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">User</span> = <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">User</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">MAX_POWER</span> = <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">MAX_POWER</span><span class="punctuation delimiter">;</span>
</code></pre>
</figure>
<p>На цьому етапі у вас може виникнути більше питань, ніж відповідей. У наведеному вище фрагменті, що таке <code>user</code>? Ми ще цього не бачили, але що, якщо використовувати <code>var</code> замість <code>const</code>? Або, можливо, вам цікаво, як використовувати сторонні бібліотеки. Усе це хороші запитання, але щоб відповісти на них, нам спочатку потрібно більше дізнатися про Zig. Наразі нам доведеться задовольнитися тим, що ми навчилися: як імпортувати стандартну бібліотеку Zig, як імпортувати інші файли та як експортувати визначення.</p><h2>Коментарі</h2><p>Наступний рядок нашого прикладу Zig є коментарем:</p><pre><code class="zig"><span class="comment">// Цей код не буде скомпільовано, якщо `main` не `pub` (публічний)</span>
</code></pre>
<p>Zig не має багаторядкових коментарів, як-от <code>/* ... */</code> у C.</p><p>Існує експериментальна підтримка автоматичного створення документації на основі коментарів. Якщо ви бачили <a href="https://ziglang.org/documentation/master/std">документацію стандартної бібліотеки</a> Zig, то ви бачили це в дії. <code>//!</code> відомий як коментар верхнього рівня і може бути розміщений у верхній частині файлу. Коментар із потрійною скісною рискою (<code>///</code>), відомий як коментар документації, може розташовуватися в певних місцях, наприклад перед оголошенням. Ви отримаєте помилку компілятора, якщо спробуєте використати будь-який тип коментаря до документа не в тому місці.</p><h2>Функції</h2><p>Наш наступний рядок коду є початком нашої функції <code>main</code>:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span><span class="punctuation delimiter"></span>
</code></pre>
<p>Кожен виконуваний файл потребує функції під назвою <code>main</code>: це точка входу в програму. Якби ми перейменували <code>main</code> на щось інше, наприклад <code>doIt</code>, і спробували запустити <code>zig run learning.zig</code>, ми б отримали повідомлення про помилку, що <i>'learning' не має члена з іменем 'main'</i>.</p><p>Ігноруючи особливу роль <code>main</code> як точки входу в нашу програму, це справді проста функція: вона не приймає параметрів і нічого не повертає, так само як <code>void</code>. Наступне <i>трохи</i> цікавіше:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">sum</span> = <span class="variable">add</span><span class="punctuation bracket">(</span><span class="number">8999</span><span class="punctuation delimiter">,</span> <span class="number">2</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"8999 + 2 = {d}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">sum</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="keyword function">fn</span> <span class="function">add</span><span class="punctuation bracket">(</span><span class="parameter">a</span><span class="punctuation delimiter">:</span> <span class="type builtin">i64</span><span class="punctuation delimiter">,</span> <span class="parameter">b</span><span class="punctuation delimiter">:</span> <span class="type builtin">i64</span><span class="punctuation bracket">)</span> <span class="type builtin">i64</span> <span class="punctuation bracket">{</span>
  <span class="keyword return">return</span> <span class="variable">a</span> <span class="operator">+</span> <span class="variable">b</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
</figure>
<p>Програмісти на C та C++ помітять, що Zig не потребує попередніх оголошень, тобто <code>add</code> викликається <i>перед</i> його визначенням.</p><p>Наступне, на що слід звернути увагу, це тип <code>i64</code>: 64-розрядне ціле число зі знаком. Деякі інші числові типи: <code>u8</code>, <code>i8</code>, <code>u16</code>, <code>i16</code>, <code>u32</code> , <code>i32</code>, <code>u47</code>, <code>i47</code>, <code>u64</code>, <code>i64</code>, <code>f32 </code> і <code>f64</code>. Включення <code>u47</code> та <code>i47</code> не є перевіркою, щоб переконатися, що ви все ще не спите; Zig підтримує довільні цілі числа з бітовою шириною. Хоча ви, ймовірно, не будете використовувати їх часто, вони можуть стати в нагоді. Одним із типів, які ви <i>використовуєте</i> часто, є <code>usize</code>, який є цілим числом беззнакового вказівника та, як правило, типом, який представляє довжину/розмір чогось.</p><hr><blockquote><p>Крім <code>f32</code> і <code>f64</code>, Zig також підтримує <code>f16</code>, <code>f80</code> і <code>f128</code> типи з плаваючою комою.</p></blockquote><hr><p>Хоча для цього немає вагомих причин, якщо ми змінимо реалізацію <code>add</code> на:</p><pre><code class="zig"><span class="keyword function">fn</span> <span class="function">add</span><span class="punctuation bracket">(</span><span class="parameter">a</span><span class="punctuation delimiter">:</span> <span class="type builtin">i64</span><span class="punctuation delimiter">,</span> <span class="parameter">b</span><span class="punctuation delimiter">:</span> <span class="type builtin">i64</span><span class="punctuation bracket">)</span> <span class="type builtin">i64</span> <span class="punctuation bracket">{</span>
  <span class="variable">a</span> <span class="operator">+=</span> <span class="variable">b</span><span class="punctuation delimiter">;</span>
  <span class="keyword return">return</span> <span class="variable">a</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Ми отримаємо помилку на <code>a += b;</code>: <i>cannot assign to constant</i>. Це важливий урок, який ми переглянемо більш детально пізніше: параметри функції є константами.</p><p>Для кращої зручності читання немає перевантаження функції (одна і та сама функція з назвою, визначеною різними типами параметрів та/або кількістю параметрів). Наразі це все, що нам потрібно знати про функції.</p><h2>Структури (struct)</h2><p>Наступний рядок коду — це створення <code>User</code>, тип якого визначено в кінці нашого фрагмента коду. Визначення <code>User</code> таке:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation delimiter">,</span>
  <span class="field">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<hr><blockquote><p>Оскільки наша програма є одним файлом і тому <code>User</code> використовується лише у файлі, де він визначений, нам не потрібно робити його <code>pub</code>. Але тоді ми б не могли надати оголошення іншим файлам.</p></blockquote><hr><p>Поля структури закінчуються комою та можуть мати значення за замовчуванням:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span> = <span class="number">0</span><span class="punctuation delimiter">,</span>
  <span class="field">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Коли ми створюємо структуру, <strong>кожне</strong> поле має бути встановлено. Наприклад, у вихідному визначенні, де <code>power</code> не мав значення за замовчуванням, наступне давало б помилку: <strong>missing struct field: power</strong></p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">user</span> = <span class="variable">User</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="string">"Goku"</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Однак із нашим значенням за замовчуванням наведене вище компілюється нормально.</p><p>Структури можуть мати методи, вони можуть містити оголошення (включно з іншими структурами) і навіть можуть містити нульові поля, після чого вони діють більше як простір імен.</p><pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span> = <span class="number">0</span><span class="punctuation delimiter">,</span>
  <span class="field">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>

  <span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">SUPER_POWER</span> = <span class="number">9000</span><span class="punctuation delimiter">;</span>

  <span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">diagnose</span><span class="punctuation bracket">(</span><span class="parameter">user</span><span class="punctuation delimiter">:</span> <span class="variable">User</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span> <span class="operator">&gt;=</span> <span class="variable">SUPER_POWER</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">{</span>
      <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"це більше аніж {d}!!!"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">SUPER_POWER</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
  <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Методи — це звичайні функції, які можна викликати "через крапку". Обидва вони працюють:</p><pre><code class="zig"><span class="comment">// виклик функції diagnose для деякого екземпляра User</span>
<span class="variable">user</span><span class="punctuation delimiter">.</span><span class="function">diagnose</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="error">;

// Вище - це "синтаксичний цукор" для отакої повної форми:
User</span><span class="punctuation delimiter">.</span><span class="variable builtin">diagnose</span><span class="punctuation bracket">(</span><span class="variable">user</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>Здебільшого ви будете використовувати синтаксис крапок, але методи, як синтаксичний цукор над звичайними функціями, можуть стати в нагоді.</p><hr><blockquote><p>Оператор <code>if</code> — це перший потік керування, який ми побачили. Досить просто, правда? Ми розглянемо це більш детально в наступній частині.</p></blockquote><hr><p><code>diagnose</code> визначається в нашому типі <code>User</code> і приймає <code>User</code> як свій перший параметр. Таким чином, ми можемо визвати його за допомогою крапкового синтаксису. Але функції всередині структури <i>необов'язково</i> слідувати цьому шаблону. Одним із поширених прикладів є функції <code>init</code> для ініціювання нашої структури:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="type qualifier">const</span> <span class="variable">User</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
  <span class="field">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span> = <span class="number">0</span><span class="punctuation delimiter">,</span>
  <span class="field">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span>

  <span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="parameter">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="parameter">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation bracket">)</span> <span class="variable">User</span> <span class="punctuation bracket">{</span>
    <span class="keyword return">return</span> <span class="variable">User</span><span class="punctuation bracket">{</span>
      <span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="variable">name</span><span class="punctuation delimiter">,</span>
      <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="variable">power</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter"></span>
</code></pre>
<p>Використання <code>init</code> є просто домовленістю, і в деяких випадках <code>open</code> або інша назва може мати більше сенсу. Якщо ви схожі на мене, а не програміст на C++, синтаксис ініціалізації полів, <code>.$field = $value,</code> може здатися трохи дивним, але ви швидко до нього звикнете.</p><p>Коли ми створювали «Goku», ми оголосили змінну <code>user</code> як <code>const</code>:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">user</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
  <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">9001</span><span class="punctuation delimiter">,</span>
  <span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="string">"Goku"</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Це означає, що ми не можемо модифікувати <code>user</code>. Щоб мати можливість модифікувати змінну, її слід оголосити за допомогою ключового слова <code>var</code>. Крім того, ви могли помітити, що тип <code>user</code> виводиться на основі того, що йому призначається. Ми могли б явно вказати:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">user</span><span class="punctuation delimiter">:</span> <span class="variable">User</span> = <span class="variable">User</span><span class="punctuation bracket">{</span>
  <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">9001</span><span class="punctuation delimiter">,</span>
  <span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="string">"Goku"</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Ми побачимо випадки, коли нам доведеться явно вказати тип змінної, але в більшості випадків код легше читається без явного типу. Виведення типу працює і в інший спосіб. Це еквівалентно обом наведеним вище фрагментам:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">user</span><span class="punctuation delimiter">:</span> <span class="variable">User</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
  <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="number">9001</span><span class="punctuation delimiter">,</span>
  <span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="string">"Goku"</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Однак це використання досить незвичне. Єдине місце, де це більш поширене, це повернення структури з функції. Тут тип можна вивести з типу, що повертається функцією. Наша функція <code>init</code> швидше за все буде написана так:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">init</span><span class="punctuation bracket">(</span><span class="parameter">name</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="parameter">power</span><span class="punctuation delimiter">:</span> <span class="type builtin">u64</span><span class="punctuation bracket">)</span> <span class="variable">User</span> <span class="punctuation bracket">{</span>
  <span class="comment">// замість return User{...}</span>
  <span class="keyword return">return</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">name</span> = <span class="variable">name</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">power</span> = <span class="variable">power</span><span class="punctuation delimiter">,</span>
  <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>Як і більшість речей, які ми розглядали досі, ми переглянемо структури в майбутньому, коли будемо говорити про інші частини мови. Але здебільшого вони прості.</p><h2>Масиви та зрізи</h2><p>Ми могли б замовчати останній рядок нашого прикладу, але враховуючи, що наш невеликий фрагмент коду містить два рядки, "Goku" та «сила {s} — {d}\n», вам, мабуть, цікаво про рядки в Zig. Щоб краще зрозуміти рядки, давайте спочатку дослідимо масиви та зрізи.</p><p>Масиви мають фіксований розмір із відомою довжиною під час компіляції. Довжина є частиною типу, тому масив із 4 цілих чисел зі знаком, <code>[4]i32</code>, є іншим типом, ніж масив із 5 цілих чисел зі знаком, <code>[5]i32</code>.</p><p>Довжину масиву можна визначити з ініціалізації. У наведеному нижче коді всі три змінні мають тип <code>[5]i32</code>:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">a</span> = <span class="punctuation bracket">[</span><span class="number">5</span><span class="punctuation bracket">]</span><span class="type builtin">i32</span><span class="punctuation bracket">{</span><span class="number">1</span><span class="punctuation delimiter">,</span> <span class="number">2</span><span class="punctuation delimiter">,</span> <span class="number">3</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation delimiter">,</span> <span class="number">5</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

<span class="comment">// ми вже бачили цей синтаксис .{...} зі структурами</span>
<span class="comment">// він також працює з масивами</span>
<span class="type qualifier">const</span> <span class="variable">b</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="number">5</span><span class="punctuation bracket">]</span><span class="type builtin">i32</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="number">1</span><span class="punctuation delimiter">,</span> <span class="number">2</span><span class="punctuation delimiter">,</span> <span class="number">3</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation delimiter">,</span> <span class="number">5</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

<span class="comment">// використовуйте _, щоб дозволити компілятору визначити довжину</span>
<span class="type qualifier">const</span> <span class="variable">c</span> = <span class="punctuation bracket">[</span><span class="variable builtin">_</span><span class="punctuation bracket">]</span><span class="type builtin">i32</span><span class="punctuation bracket">{</span><span class="number">1</span><span class="punctuation delimiter">,</span> <span class="number">2</span><span class="punctuation delimiter">,</span> <span class="number">3</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation delimiter">,</span> <span class="number">5</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>З іншого боку, зріз є вказівником на масив із довжиною. Довжина відома під час виконання. Пізніше ми розглянемо вказівники, але ви можете розглядати зріз як таке "вікно" в масив.</p><hr><blockquote><p>Якщо ви знайомі з Go, ви могли помітити, що зрізи в Zig дещо інші: вони <strong>не</strong> мають ємність, лише вказівник і довжину.</p></blockquote><hr><p>Враховуючи наступне,</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">a</span> = <span class="punctuation bracket">[</span><span class="variable builtin">_</span><span class="punctuation bracket">]</span><span class="type builtin">i32</span><span class="punctuation bracket">{</span><span class="number">1</span><span class="punctuation delimiter">,</span> <span class="number">2</span><span class="punctuation delimiter">,</span> <span class="number">3</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation delimiter">,</span> <span class="number">5</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">b</span> = <span class="variable">a</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation special">..</span><span class="number">4</span><span class="punctuation bracket">]</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Мені хотілося б сказати вам, що <code>b</code> — це зріз довжиною 3 і вказівником на <code>a</code>. Але оскільки ми «розрізали» наш масив за допомогою значень, відомих під час компіляції, наприклад <code>1</code> і <code>4</code>, наша довжина <code>3</code> також відома під час компіляції. Zig все це визначає, тому <code>b</code> не є зрізом, а вказівником на масив цілих чисел довжиною 3. Зокрема, його тип <code>*const [3]i32 </code>. Отже, ця демонстрація зріза була зірвана кмітливістю Zig.</p><p>У реальному коді ви, швидше за все, використовуватимете зрізи частіше, ніж масиви. Добре чи погано, але програми, як правило, мають більше інформації під час виконання, ніж під час компіляції. Однак у маленькому прикладі ми повинні обдурити компілятор, щоб отримати те, що ми хочемо:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">a</span> = <span class="punctuation bracket">[</span><span class="variable builtin">_</span><span class="punctuation bracket">]</span><span class="type builtin">i32</span><span class="punctuation bracket">{</span><span class="number">1</span><span class="punctuation delimiter">,</span> <span class="number">2</span><span class="punctuation delimiter">,</span> <span class="number">3</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation delimiter">,</span> <span class="number">5</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">var</span> <span class="variable">end</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span> = <span class="number">3</span><span class="punctuation delimiter">;</span>
<span class="variable">end</span> <span class="error">+=</span> <span class="number">1</span><span class="error">;</span>
<span class="type qualifier">const</span> <span class="variable">b</span> = <span class="variable">a</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation special">..</span><span class="variable">end</span><span class="punctuation bracket">]</span><span class="punctuation delimiter">;</span>
</code></pre>
<p><code>b</code> тепер є правильним зрізом, зокрема його тип <code>[]const i32</code>. Ви бачите, що довжина зрізу не є частиною типу, оскільки вона відома лише під час виконання, а типи завжди повністю відомі під час компіляції. Під час створення зрізу ми можемо опустити верхню межу, щоб створити зріз до кінця того, що ми нарізаємо (або масиву, або зрізу), наприклад. <code>const c = b[2..];</code>.</p><hr><blockquote><p>Якби ми зробили <code>const end: usize = 4</code> без приросту, тоді <code>1..end</code> став би відомою довжиною під час компіляції для <code>b </code> і таким чином створив вказівник на масив, а не на зріз. Я вважаю це трохи заплутаним, але це не те, що виникає надто часто, і це не надто важко освоїти. Я хотів би пропустити це на цьому етапі, але не міг знайти чесного способу уникнути цієї деталі.</p></blockquote><hr><p>Вивчення Zig навчило мене, що типи дуже описові. Це не просто ціле чи логічне значення чи навіть масив 32-розрядних цілих чисел зі знаком. Типи також містять іншу важливу інформацію. Ми говорили про те, що довжина є частиною типу масиву, і багато прикладів показали, що незмінність (const-ness) також є його частиною. Наприклад, у нашому останньому прикладі тип <code>b</code> — <code>[]const i32</code>. Ви можете переконатися в цьому за допомогою наступного коду:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">const</span> <span class="variable">a</span> = <span class="punctuation bracket">[</span><span class="variable builtin">_</span><span class="punctuation bracket">]</span><span class="type builtin">i32</span><span class="punctuation bracket">{</span><span class="number">1</span><span class="punctuation delimiter">,</span> <span class="number">2</span><span class="punctuation delimiter">,</span> <span class="number">3</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation delimiter">,</span> <span class="number">5</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">var</span> <span class="variable">end</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span> = <span class="number">4</span><span class="punctuation delimiter">;</span>
  <span class="variable">end</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">b</span> = <span class="variable">a</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation special">..</span><span class="variable">end</span><span class="punctuation bracket">]</span><span class="punctuation delimiter">;</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{any}"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="variable">b</span><span class="punctuation bracket">)</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
</figure>
<p>Якщо ми спробуємо записати в <code>b</code>, наприклад <code>b[2] = 5;</code>, ми отримаємо помилку під час компіляції: <i>cannot assign to constant</i>. Це через тип <code>b</code>.</p><p>Щоб вирішити цю проблему, у вас може виникнути спокуса внести цю зміну:</p><pre><code class="zig"><span class="comment">// замінити const на var</span>
<span class="type qualifier">var</span> <span class="variable">b</span> = <span class="variable">a</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation special">..</span><span class="variable">end</span><span class="punctuation bracket">]</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>але ви отримаєте ту саму помилку, чому? Як підказку, який тип <code>b</code>, або загальніше, що таке <code>b</code>? Зріз — це довжина та покажчик на [частину] масиву. Тип зрізу завжди походить від того, що він нарізає. Незалежно від того, чи <code>b</code> оголошено <code>const</code> чи ні, він є зрізом <code>[5]const i32</code>, тому b має бути типу <code> []const i32</code>. Якщо ми хочемо мати можливість писати в <code>b</code>, нам потрібно змінити <code>a</code> з <code>const</code> на <code>var</code></p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">a</span> = <span class="punctuation bracket">[</span><span class="variable builtin">_</span><span class="punctuation bracket">]</span><span class="type builtin">i32</span><span class="punctuation bracket">{</span><span class="number">1</span><span class="punctuation delimiter">,</span> <span class="number">2</span><span class="punctuation delimiter">,</span> <span class="number">3</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation delimiter">,</span> <span class="number">5</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">var</span> <span class="variable">end</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span> = <span class="number">3</span><span class="punctuation delimiter">;</span>
  <span class="variable">end</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">b</span> = <span class="variable">a</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation special">..</span><span class="variable">end</span><span class="punctuation bracket">]</span><span class="punctuation delimiter">;</span>
  <span class="variable">b</span><span class="punctuation bracket">[</span><span class="number">2</span><span class="punctuation bracket">]</span> <span class="operator">=</span> <span class="number">99</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
</figure>
<p>Це працює, оскільки наш зріз більше не <code>[]const i32</code>, а скоріше <code>[]i32</code>. Можливо, ви розумно дивуєтесь, чому це працює, коли <code>b</code> все ще є <code>const</code>. Але постійність <code>b</code> стосується самого <code>b</code>, а не даних, на які вказує <code>b</code>. Що ж, я не впевнений, що це чудове пояснення, але для мене цей код підкреслює різницю:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="type qualifier">var</span> <span class="variable">a</span> = <span class="punctuation bracket">[</span><span class="variable builtin">_</span><span class="punctuation bracket">]</span><span class="type builtin">i32</span><span class="punctuation bracket">{</span><span class="number">1</span><span class="punctuation delimiter">,</span> <span class="number">2</span><span class="punctuation delimiter">,</span> <span class="number">3</span><span class="punctuation delimiter">,</span> <span class="number">4</span><span class="punctuation delimiter">,</span> <span class="number">5</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">var</span> <span class="variable">end</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span> = <span class="number">3</span><span class="punctuation delimiter">;</span>
  <span class="variable">end</span> <span class="operator">+=</span> <span class="number">1</span><span class="punctuation delimiter">;</span>
  <span class="type qualifier">const</span> <span class="variable">b</span> = <span class="variable">a</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation special">..</span><span class="variable">end</span><span class="punctuation bracket">]</span><span class="punctuation delimiter">;</span>
  <span class="variable">b</span> <span class="operator">=</span> <span class="variable">b</span><span class="punctuation bracket">[</span><span class="number">1</span><span class="punctuation special">..</span><span class="punctuation bracket">]</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
</figure>
<p>Це не компілюється; як каже нам компілятор, ми <i>cannot assign to constant</i>. Але якби ми виконали <code>var b = a[1..end];</code>, тоді код працював би, оскільки сам <code>b</code> більше не є константою.</p><p>Ми дізнаємося більше про масиви та зрізи, розглядаючи інші аспекти мови, не останньою з яких є рядки.</p><h2>Рядки</h2><p>Я хотів би сказати, що Zig має тип <code>string</code>, і це чудово. На жаль, це не так, і вони не є такими. У найпростішому вигляді рядки Zig — це послідовності (тобто масиви або зрізи) байтів (<code>u8</code>). Ми фактично бачили це у визначенні поля <code>name</code>: <code>name: []const u8,</code>.</p><p>Згідно з угодою та лише за угодою, такі рядки мають містити лише значення UTF-8, оскільки вихідний код Zig сам закодований у UTF-8. Але це не застосовується, і насправді немає різниці між <code>[]const u8</code>, який представляє рядок ASCII або UTF-8, і <code>[]const u8</code>, який представляє довільний двійковий код даних. Як це могло бути, вони одного типу.</p><p>З того, що ми дізналися про масиви та зрізи, ви маєте розуміння, якщо припустити, що <code>[]const u8</code> — це зріз до сталого масиву байтів (де байт — це 8-біт без знаку) ціле число). Але ніде в нашому коді ми не розрізали масив або навіть не мали масиву, вірно? Все, що ми зробили, це призначили «Goku» <code>user.name</code>. Як це спрацювало?</p><p>Рядкові літерали, які ви бачите у вихідному коді, мають відому довжину під час компіляції. Компілятор знає, що «Goku» має довжину 4. Отже, ви б були близькі до думки, що «Goku» найкраще представлено масивом, щось на зразок <code>[4]const u8</code>. Але рядкові літерали мають пару особливих властивостей. Вони зберігаються в спеціальному місці в двійковому файлі та дедуплікуються. Таким чином, змінна рядкового літералу буде вказівником на це спеціальне розташування. Це означає, що тип «Goku» ближчий до <code>*const [4]u8</code>, вказівника на постійний масив із 4 байтів.</p><p>Але це ще не все. Рядкові літерали завершуються нулем. Тобто вони завжди мають <code>\0</code> у кінці. Рядки з нульовим завершенням важливі під час взаємодії з C. У пам’яті «Goku» насправді виглядатиме так: <code>{'G', 'o', 'k', 'u', 0}</code>, тому ви можете подумати, що тип <code>*const [5]u8</code>. Але в кращому випадку це буде неоднозначним, а в гіршому – небезпечним (ви можете перезаписати нульовий термінатор). Натомість Zig має окремий синтаксис для представлення масивів із завершенням нулем. "Goku" має тип: <code>*const [4:0]u8</code>, вказівник на масив із 4 байтів із завершеаючим нулем. Говорячи про рядки, ми зосереджуємось на масивах байтів із завершеаючим нулем (оскільки так рядки зазвичай представлені в C), синтаксис більш загальний: <code>[LENGTH:SENTINEL]</code>, де "SENTINEL" це спеціальне значення, знайдене в кінці масиву. Отже, хоча я не можу зрозуміти, навіщо вам це потрібно, наступне є цілком коректним:</p><figure>
<figcaption class="zig-cap">learning.zig</figcaption>
<pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">"std"</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span>
  <span class="comment">// масив із 3 бульових значень із false як sentinel значення</span>
  <span class="type qualifier">const</span> <span class="variable">a</span> = <span class="punctuation bracket">[</span><span class="number">3</span><span class="punctuation delimiter">:</span><span class="boolean">false</span><span class="punctuation bracket">]</span><span class="type builtin">bool</span><span class="punctuation bracket">{</span><span class="boolean">false</span><span class="punctuation delimiter">,</span> <span class="boolean">true</span><span class="punctuation delimiter">,</span> <span class="boolean">false</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

  <span class="comment">// цей рядок більш складніший. то пояснення не буде</span>
  <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{any}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">mem</span><span class="punctuation delimiter">.</span><span class="function">asBytes</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">a</span><span class="punctuation bracket">)</span><span class="operator">.*</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
</figure>
<p>Який виводить: <code>{ 0, 1, 0, 0}</code>.</p></p><hr><blockquote><p>Я не вагався включити цей приклад, незважаючи на те, що останній рядок є досить складним, і я не збираюся його пояснювати. З іншого боку, це робочий приклад, який ви можете запустити та погратись з ним, щоб краще вивчити те, що ми обговорювали досі, якщо забажаєте.</p></blockquote><hr><p>Ймовірно, ще маєте сумніви. Якщо «Гоку» це <code>*const [4:0]u8</code>, чому ми змогли призначити його <code>name</code>, <code>[]const u8</code>? Відповідь проста: Zig приводить тип (coercion) автоматично. Він робить це між декількома різними типами, але це найбільш очевидно з рядками. Це означає, що якщо функція має параметр <code>[]const u8</code> або структура має поле <code>[]const u8</code>, то можна використовувати рядкові літерали. Оскільки рядки з нульовим завершенням є масивами, а масиви мають відому довжину, це приведення є дешевим, тобто воно <strong>не</strong> потребує проходження по всьому рядку, щоб знайти нульовий термінатор.</p><p>Отже, говорячи про рядки, ми зазвичай маємо на увазі <code>[]const u8</code>. Якщо необхідно, ми явно вказуємо рядок із нульовим завершенням, який може бути автоматично приведений до <code>[]const u8</code>. Але пам’ятайте, що <code>[]const u8</code> також використовується для представлення довільних двійкових даних, і тому Zig не має поняття рядка, як у мовах програмування вищого рівня. Крім того, стандартна бібліотека Zig має лише дуже простий модуль Юнікод.</p><p>Звичайно, у "реальній програмі" більшість рядків (і, загалом, масивів) невідомі під час компіляції. Класичним прикладом є введення даних від користувача, яке невідомо під час компіляції програми. Це те, до чого нам доведеться повернутися, коли ми будемо говорити про пам’ять. Але коротка відповідь полягає в тому, що для таких даних, які мають невідоме значення під час компіляції та, отже, невідому довжину, ми будемо динамічно розподіляти пам’ять під час виконання. Наші рядкові змінні, як і раніше типу <code>[]const u8</code>, будуть зрізами, які вказуватимуть на цю динамічно виділену пам’ять.</p><h2>comptime та anytype</h2><p>У нашому останньому недослідженому рядку коду є набагато більше, ніж здається на перший погляд:</p><pre><code class="zig"><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{s} має силу {d}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">name</span><span class="punctuation delimiter">,</span> <span class="variable">user</span><span class="punctuation delimiter">.</span><span class="field">power</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>Ми лише похабцем розглянимо його, але він дає можливість висвітлити деякі потужніші можливості Zig. Це речі, про які ви повинні принаймні знати, навіть якщо ви їх не засвоїли.</p><p>Перший — це концепція Zig щодо виконання під час компіляції, або <code>comptime</code>. Це основа метапрограмування Zig і, як випливає з назви, обертається навколо запуску коду під час компіляції, а не під час виконання. У цьому посібнику ми лише доторкнемося до поверхні того, що можливо за допомогою <code>comptime</code>, але це те, що постійно тут.</p><p>Можливо, вам цікаво, що таке в наведеному вище рядку, що вимагає виконання під час компіляції. Визначення функції <code>print</code> вимагає, щоб наш перший параметр, формат рядка, був відомий під час компіляції:</p><pre><code class="zig"><span class="comment">// зверніть увагу що "comptime" знаходиться перед параметром "fmt"</span>
<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">print</span><span class="punctuation bracket">(</span><span class="attribute">comptime</span> <span class="parameter">fmt</span><span class="punctuation delimiter">:</span> <span class="punctuation bracket">[</span><span class="punctuation bracket">]</span><span class="type qualifier">const</span> <span class="type builtin">u8</span><span class="punctuation delimiter">,</span> <span class="parameter">args</span><span class="punctuation delimiter">:</span> <span class="type builtin">anytype</span><span class="punctuation bracket">)</span> <span class="type builtin">void</span> <span class="punctuation bracket">{</span><span class="punctuation bracket"></span>
</code></pre>
<p>І причина цього полягає в тому, що <code>print</code> виконує додаткові перевірки під час компіляції, які ви не отримаєте в більшості інших мов програмування. Що за перевірки? Скажімо, ви змінили формат на <code>"це більше за {d}\n"</code>, але зберегли два аргументи. Ви отримаєте помилку під час компіляції: <i>unused argument in "це більше за {d}</i>. Він також виконуватиме перевірки типу: змініть рядок формату на <code>"{s} має силу {s}\n"</code>, і ви отримаєте <i>invalid format string 's' for type 'u64</i>. Ці перевірки було б неможливо виконати під час компіляції, якби формат рядка не був відомий під час компіляції. Звідси й така вимога до параметру <code>fmt</code>.</p><p>Єдине місце, де <code>comptime</code> негайно вплине на ваше кодування, це типи за замовчуванням для цілих чисел і літералів з плаваючою точкою, спеціальні <code>comptime_int</code> і <code>comptime_float</code>. Цей рядок коду недійсний: <code>var i = 0;</code>. Ви отримаєте помилку під час компіляції: <i>variable of type 'comptime_int' must be const or comptime</i>. Код <code>comptime</code> може працювати лише з даними, відомими під час компіляції, а для цілих чисел і чисел з плаваючою точкою такі дані ідентифікуються спеціальними <code>comptime_int</code> і <code>comptime_float</code> типи. Значення цього типу можна використовувати під час виконання під час компіляції. Але ви, швидше за все, не збираєтеся витрачати більшу частину свого часу на написання коду для виконання під час компіляції, тому це не особливо корисне значення за замовчуванням. Що вам потрібно зробити, так це надати своїм змінним явний тип:</p><pre><code class="zig"><span class="type qualifier">var</span> <span class="variable">i</span><span class="punctuation delimiter">:</span> <span class="type builtin">usize</span> = <span class="number">0</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">var</span> <span class="variable">j</span><span class="punctuation delimiter">:</span> <span class="type builtin">f64</span> = <span class="number">0</span><span class="punctuation delimiter">;</span>
</code></pre>
<hr><blockquote><p>Зауважте, ця помилка сталася лише тому, що ми використовували <code>var</code>. Якби ми використовували <code>const</code>, ми б не мали помилки, оскільки вся суть помилки полягає в тому, що <code>comptime_int</code> <strong>має</strong> бути const</p></blockquote><hr><p>У наступній частині ми докладніше розглянемо comptime під час вивчення узагальнених структур даних (generics).</p><p>Ще одна особливість нашого рядка коду — це дивний <code>.{user.name, user.power}</code>, який, виходячи з наведеного вище визначення <code>print</code>, ми знаємо що він передається як тип <code>anytype</code>. Цей тип не слід плутати з чимось на кшталт <code>Object</code> Java або <code>any</code> Go (він же <code>інтерфейс{}</code>). Навпаки, під час компіляції Zig створить версію функції <code>print</code> спеціально для всіх типів, які їй передано.</p><p>Виникає запитання: що <strong>ми</strong> йому передаємо? Раніше ми вже бачили нотацію <code>.{...}</code>, коли компілятор міг визначити тип нашої структури. Це схоже: створюється анонімний структурний літерал. Розгляньте цей код:</p><pre><code class="zig"><span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span><span class="string">"{any}\n"</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="function builtin">@TypeOf</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation delimiter">.</span><span class="field">year</span> = <span class="number">2023</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="field">month</span> = <span class="number">8</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>який виведе:</p><pre><code>struct{comptime year: comptime_int = 2023, comptime month: comptime_int = 8}
</code></pre><p>Тут ми вказали наші анонімні назви полів структури, <code>year</code> і <code>month</code>. У нашому оригінальному коді ми цього не зробили. У цьому випадку назви полів автоматично генеруються як «0», «1», «2» тощо. Хоча обидва вони є прикладами анонімного структурного літералу, той, що не містить імен полів, часто називають <i>кортежем</i>. Функція <code>print</code> очікує кортеж і використовує порядкову позицію у форматі рядка, щоб отримати відповідний аргумент.</p><p>Zig не має перевантаження функцій і не має варіативних функцій (функцій із довільною кількістю аргументів). Але він має компілятор, здатний створювати спеціалізовані функції на основі переданих типів, у тому числі типів, виведених і створених самим компілятором.</p></div>
	
      </div>
    </div>
  </div>
</body>

</html>